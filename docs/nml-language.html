<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>NML documentation</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">
<link rel="stylesheet" title="Standard Style" type="text/css" href="nml.css">
</head>
<body>

<h1><a name="preface">Preface</a></h1>
<p>NewGRF files are files containing sprites and pseudo-sprites that can be
used to describe extra vehicles, industries, cargoes etc. for use in OpenTTD
and TTDPatch. The most used tool to encode/decode GRF files is
<a href="http://dev.openttdcoop.org/projects/grfcodec">GRFCodec</a>
(<a href="http://www.openttd.org/download-grfcodec">nightly download</a>).
GRFCodec can read NFO files and convert them to GRF files
(<a href="http://www.ttdpatch.net/grfcodec/grf.html">GRF file format</a>).
NFO is a low-level language that is tied to the GRF spec. It uses hexadecimal
numbers by default in most places and doesn't have any textual identifiers.
While the language is very powerful, it's also hard to learn. NML was started
mainly to provide a higher level language so coding GRF files will become
accessible to more people.</p>
<p>
A good place to discuss NewGRFs which are being developed are the
<a href="http://tt-forums.net">tt-forums</a>, especially the
<a href="http://www.tt-forums.net/viewforum.php?f=66">NewGRF sub-sections</a>.
Questions concerning setup up of NewGRF projects, programming or drawing or
just discussing features and presenting work being done are well-placed there.
When you are satisfied with a NewGRF and consider it tested enough that it really
can be considered to be played with by the general public, you can publish your NewGRF in the 
<a href="http://www.tt-forums.net/viewforum.php?f=67">NewGRF releases sub-forum</a>
and you might also consider to publish it to the
<a href="http://bananas.openttd.org">Online Content Server</a>
of OpenTTD, so that other players can easily download your NewGRF and use it for
future games. It will increase the popularity and use of your NewGRF tremendously.</p>

<p><img alt="encoding process of nml" src="compileprocess.png"></p>

<h1><a name="installation">Getting started</a></h1>
<p>
NML is a a python-based compiler, capable to compile NML files (along with their
associated language, sound and graphic files) into grf and / or nfo files. In
order to work, it requires
<ul>
<li><b>python</b>
    <ul>
        <li>any version from 2.5 through 2.7 will do, but not 3.x</li>
        <li>downloadable from from <a href="http://www.python.org/">http://www.python.org/</a>)</li>
    </ul>
<li><b>python image library</b>
    <ul>
        <li>downloadable from <a href="http://www.pythonware.com/products/pil/">http://www.pythonware.com/products/pil/</a></li>
    </ul>
<li><b>ply</b>
    <ul>
        <li>downloadable from <a href="http://www.dabeaz.com/ply/">http://www.dabeaz.com/ply/</a></li>
    </ul>
</ul>

If you don't install these with the packet manager of your choice (or there is none like on windows),
you should install these libraries as well as NML itself using <code class="ex">python setup.py install</code> from your
command prompt.

Examples for small NML "projects" are found in the <code class="ex">regression</code>
folder of NML. Generally it's assumed that the language files are in a separate
language folder <code class="ex">lang</code>, thus a simple project may look like this:
<pre>
mynewgrf.nml
graphics.png
funny_sound.wav

lang/default.lng
</pre>
</p><p>
The compiler itself <code class="ex">nmlc</code> is a command line tool and can
take a number of parameters, at least the nml filename which it shall process,
e.g. <code class="ex">nmlc mynewgrf.nml</code> will compile your nml file into
the grf-file <code class="ex">mynewgrf.grf</code>.
</p><p>
The full syntax is:
<pre class="code">
Usage: nmlc [options] &lt;filename&gt;
Where &lt;filename&gt; is the nml file to parse

Options:
  --version             show program's version number and exit
  -h, --help            show this help message and exit
  -d, --debug           write the AST to stdout
  -s, --stack           Dump stack when an error occurs
  --grf=&lt;file&gt;          write the resulting grf to &lt;file&gt;
  --nfo=&lt;file&gt;          write nfo output to &lt;file&gt;
  -c                    crop extraneous transparent blue from real sprites
  -u                    save uncompressed data in the grf file
  --nml=&lt;file&gt;          write optimized nml to &lt;file&gt;
  -o &lt;file&gt;, --output=&lt;file&gt;
                        write output(nfo/grf) to &lt;file&gt;
  -t &lt;file&gt;, --custom-tags=&lt;file&gt;
                        Load custom tags from &lt;file&gt; [default:
                        custom_tags.txt]
  -l &lt;dir&gt;, --lang-dir=&lt;dir&gt;
                        Load language files from directory &lt;dir&gt; [default:
                        lang]
</pre>

<h1><a name="graphic-files">Graphic files</a></h1>
<p>All graphic files must be in a format that can be loaded by the python imaging library
and they must have a valid palette. You can chose either the DOS palette (recommended as
it contains a few more colours) or the windows palette.</p>
<p>Palette files for several editors:
<ul>
<li><a href="ttd-newgrf-dos.gpl">Dos palette for GIMP</a></li>
<li><a href="ttd-newgrf-win.gpl">Windows palette for GIMP</a></li>
<li><a href="ttd-newgrf-win.act">Windows palette for Photoshop</a></li>
</ul>
</p>

<h1><a name="structure">Language structure</a></h1>
<h2><a name="structure-blocks">Blocks</a></h2>
<p>NML files are mainly composed from blocks. A block starts with the type of
the block, optional arguments and then the contents enclosed by curly braces.
Nearly all NML files will start with a <a href="#block-grf">grf-block</a>. The
grf-block takes no parameters and is one of the simplest blocks there is.
Following is an example grf-block.</p>
<pre class="code">grf {
	grfid : "AB\02\03";
	name : string(STR_GRF_NAME);
	desc : string(STR_GRF_DESCRIPTION);
	version: 10;
	min_compatible_version: 5;
}</pre>
<p>Let's look at this code line for line.</p>
<pre class="code">grf {</pre>
<p>This block is a grf-block. A grf-block has no parameters. The '{' is the
start of the block content.</p>
<pre class="code">	grfid : "AB\02\03";</pre>
<p>This line sets the grfid of the resulting grf. The value is the letters AB
followed by a byte with value 2 and then another one with value 3. The
semicolon marks the end of the statement.</p>
<pre class="code">	name : string(STR_GRF_NAME);</pre>
<p>The name of the grf. In NML nearly all strings are put in
<a href="language-files.html#language-files">language files</a>. The format of the language files
is described in another section. For now just assume a string with the name
<code>STR_GRF_NAME</code> exists. To reference a string from the language file
you use <code>string(&lt;stringname&gt;)</code> where <code>&lt;stringname&gt;</code>
should be replaced by the actual name of the string.</p>
<pre class="code">	desc : string(STR_GRF_DESCRIPTION);</pre>
<p>This looks a lot like the previous line, only it sets the description
instead of the name.</p>
<pre class="code">	version : 10;</pre>
<p>For a new grf you should set the version to 1. Every time you release a new
version you should increase the version field by at least 1.</p>
<pre class="code">	min_compatible_version : 5;</pre>
<p>For a new grf you should set the min_compatible_version to 1. Every time you change
something in your newgrf which makes it incompatible to previous versions, you should
set min_compatible_version to the current version. Changes which make a NewGRF
incompatible to previous versions are most functional changes to existing behaviour, 
among others: changing vehicleIDs as well as some of their properties, changing
industry layouts, railtype compatibility, changing (de-)activation conditions... 
Adding new, additional things and expanding existing behaviour (without changing the
current one) is mostly considered safe).</p>
<pre class="code">}</pre>
<p>This marks the end of the last-opened block, in this case the grf-block.</p>

<h2><a name="structure-features">Features</a></h2>
<p>NewGRFs can be used to modify various types of items. Examples include trains,
stations and industries. Such a type of item is called a <em>feature</em>. The
following table contains a list of features and their identifiers. These
identifiers may be used to refer to the feature when needed.</p>
<table class="t">
<tr><th>Name<th>Description
<tr><td>FEAT_TRAINS<td>Trains
<tr><td>FEAT_ROADVEHS<td>Road vehicles
<tr><td>FEAT_SHIPS<td>Ships
<tr><td>FEAT_AIRCRAFT<td>Aircraft
<tr><td>FEAT_STATIONS<td>Train stations
<tr><td>FEAT_CANALS<td>Canals
<tr><td>FEAT_BRIDGES<td>Bridges
<tr><td>FEAT_HOUSES<td>Town houses
<tr><td>FEAT_GLOBALVARS<td>Various global variables
<tr><td>FEAT_INDUSTRYTILES<td>Industry tiles (visible part of industries)
<tr><td>FEAT_INDUSTRIES<td>Industries
<tr><td>FEAT_CARGOS<td>Cargo types
<tr><td>FEAT_SOUNDEFFECTS<td>Sound effects
<tr><td>FEAT_AIRPORTS<td>Airports
<tr><td>FEAT_SIGNALS<td>Train signals
<tr><td>FEAT_OBJECTS<td>Non-interactive objects (example: lighthouse)
<tr><td>FEAT_RAILTYPES<td>Rail types
<tr><td>FEAT_AIRPORTTILES<td>Airport tiles (visible part of airports)
</table>

<h1><a name="block-syntax">Block syntax</a></h1>
<p>In the next sections you'll often see a word enclosed by the less-than and
greater-than symbols. These words should not be written literally, instead
they reference to another block/item you should put there. The following words
will be used:</p>

<dl>
<dt>&lt;literal-string&gt;</dt>
<dd>A string enclosed by quotes, for example <code>"this is a literal string"</code></dd>

<dt>&lt;string&gt;</dt>
<dd>A string defined in the language file, for example <code>string(STR_GRF_NAME)</code></dd>

<dt>&lt;expression&gt;</dt>
<dd>An expression, this can be a computation or single value constructed using &lt;number&gt;, &lt;float&gt;,
&lt;parameter&gt;, &lt;variable&gt;, &lt;function-call&gt;</dd>

<dt>&lt;ID&gt;</dt>
<dd>The name of an item or block. IDs should start with a letter or underscore.
The rest of the ID may consist of letters, underscores and numbers.</dd>

</dl>
<p>If something is enclosed by square brackets [] it's optional.</p>


<h2><a name="block-grf">GRF</a></h2>
<pre class="exl">grf {
	grfid: &lt;literal-string&gt;;
	name: &lt;string&gt;;
	desc: &lt;string&gt;;
	version: &lt;expression&gt;;
	min_compatible_version: &lt;expression&gt;;
	&lt;param { ... }&gt;
}</pre>
<p>Example:</p>
<pre class="code">grf {
	grfid: "AB\03\02";
	name: string(STR_GRF_NAME);
	desc: string(STR_GRF_DESC);
	version: 1;
	min_compatible_version: 1;
}</pre>

<h3><a name="block-grf-settings">GRF parameters</a></h3>
<p>As part of the grf block you can specify some parameter settings that the user will be able to
change as part of the newgrf configuration. These can for example be used to disable parts of your
NewGRF or to change between multiple graphics in case that's not possible at runtime. In general
the settings (sub-)block looks like
<pre class="exl">
param {
	&lt;name&gt; {
		type:    &lt;type&gt;;
		name:    &lt;string&gt;;
		desc:    &lt;string&gt;;
		min_value: &lt;expression&gt;;
		max_value: &lt;expression&gt;;
		def_value: &lt;expression&gt;;
		names: {
			0: &lt;string&gt;;
			1: &lt;string&gt;;
			.
			.
			.
		};
	}
}
</pre>
Looking at the single entries:
<pre class="code">&lt;type&gt;</pre>
This defines the parameter type. Possible values are <code>bool</code> for on/off statements
or <code>int</code> for positive integer values
<pre class="code">name</pre>
This gives the parameter name as shown in the parameter configuration dialogue of OpenTTD.
<pre class="code">desc</pre>
This gives the description which is displayed when the parameter is selected. Here you can
explain the meaning and impact it will have
<pre class="code">min_value</pre>
The minimum acceptable value for the parameter (makes only sense for type int)
<pre class="code">max_value</pre>
The maximum acceptable value for the parameter (makes only sense for type int)
<pre class="code">def_value</pre>
This sets the default value for this parameter. If left out, the default value of 0 will be
used. 
<pre class="code">names</pre>
If you chose type <code>int</code> and the numbers themselves are only used internally, have
no direct numerical meaning and are better explained in words, you can use this to associate
the single numbers with a string which describes it and is shown to the user instead of the
value.
A simple example:
<pre class="code">
param {
	param_provide {
		type:    int;
		name:    string(STR_PARAM_PROVIDE);
		desc:    string(STR_PARAM_PROVIDE_DESC);
		min_value: 0;
		max_value: 1;
		def_value: 0;
		names: {
			0: string(STR_PARAM_PROVIDE_ENGINES_AND_WAGONS);
			1: string(STR_PARAM_PROVIDE_WAGONS_ONLY);
		};
	}
</pre>
</p>

<h2><a name="block-item">Item</a></h2>
<pre class="exl">item (&lt;expression&gt; [, &lt;ID&gt; [, &lt;expression&gt;]]) {
	(&lt;property-block&gt;|&lt;graphics-block&gt;|&lt;livery_override-block&gt;)+
}</pre>
<p>The first argument is the feature of the item, the second (optional) argument
is the name used to identify the object throughout the NML file and the
third (optional) argument is the numerical id you want to
use for this item.
Example:</p>
<pre class="code">item (FEAT_ROADVEHS, hereford_tram) {
	property {
		name:               string(STR_NAME_HEREFORD_TRAM);
		climates_available: ALL_CLIMATES;
		introduction_date:  date(1940,1,1);
		speed:              60 km/h;
	}
}</pre>

<h3><a name="block-item-property">Property</a></h3>
<pre class="exl">property {
	(&lt;ID&gt;: (&lt;string&gt;|(&lt;expression&gt; [&lt;unit&gt;]));)+
}</pre>
<p>This one looks a lot more complicated than it actually is. A property-block
contains one or more assignments. Each assignment starts with the name of the
property that is changed followed by a colon. After the colon follows the value
and you end the line with a semicolon. The type of the value depends on the
property, some properties require a string as value and some an expression.
For some properties you can optionally specify a unit that is used to convert
the value to the unit that is written to the output file. You can only use
a unit if the expression is constant. <a href="#units">List of valid units</a></p>

<h3><a name="block-item-graphics">Graphics</a></h3>

<h3><a name="block-item-livery_override">Livery override</a></h3>
<div class="img_right">
<img title="Livery override: different engines, same cars, different car sprites" alt="LiveryOverride example" src="liveryoverride.png" hspace="5" vspace="5"><br>

Same cars, different engine, different car sprites
</div>
<p>A livery override block offers the option to change the look and
behaviour of a wagon depending on the engine it is attached to.
E.g. passenger wagons could adapt their livery to match the engine,
to make the consist look like a multiple-unit train. The spritegroup
needs to be defined before it can be used in a livery override. A livery
override block is always part of the engine definition and looks like</p>
<pre class="exl">
livery_override (vehicleID) {
	spritegroup_name
}
</pre>
For an example see the <a href="#block-spritgroup">spritegroup</a>

<h2><a name="block-tilelayout">Tilelayout</a></h2>

<h2><a name="block-spriteset">Spriteset</a></h2>
A spriteset associates a name with a number piece of an existing image file and describes
the offsets with respect to some origin the graphics will be painted within the game. Different
features and situations require that a single set has a certain amount of actual sprites associated.
E.g. a vehicle usually requires eight sprites in order to provide on view for each of the eight
possible ingame orientations of a vehicle.
<pre class="code">
spriteset (SPRITESET_NAME, graphics_file) {
	[left_X, upper_Y, width, height, offset_X, offset_Y]
	...
}
</pre>
<h2><a name="block-spritegroup">Spritegroup</a></h2>
A spritegroup associates the several spritesets for use and futher reference in the graphics block
of an item block.
<pre class="exl">
spritegroup spritegroup_name {
	block_name: spriteset_names
}
</pre>
The block_names vary by the feature:
<h3><a name="block-spritegroup-vehicles">Spritegroups for vehicles</a></h3>
For vehicles a typical spritegroup looks like
<pre class="exl">
spritegroup spritegroup_name {
	loading: [spriteset_name [, spriteset_name [, spriteset_name [, spriteset_name]]]]
	loaded: [spriteset_name [, spriteset_name [, spriteset_name [, spriteset_name]]]]
}
</pre>
Vehicles take two different spritesets, <code>loading</code> shows the vehicle while
it is loading within the station and <code>loaded</code> shows the vehicle while it is travelling.
Each of those can be an array of up to 4 individual spritesets and must at least be one. They're
used to show different graphics depending on how much the vehicle is loaded with increasing load
from left to right. If only one spriteset is given it will always be used.

A simple example for defining a train engine with a livery override. The passenger wagon shows
different sprites whether it is travelling empty or is filled with people.
<pre class="code">
// Define the sprites for the engine
spriteset(turbotrain_engine_set, "src/gfx/turbotrain.png") {
	[142,112,  8,22,   -3,-10]
	[158,112, 21,15,  -14, -7]
	[190,112, 31,12,  -16, -8]
	[238,112, 21,16,   -6, -7]
	[270,112,  8,24,   -3,-10]
	[286,112, 21,16,  -15, -6]
	[318,112, 32,12,  -16, -8]
	[366,112, 21,15,   -6, -7]
}
// Define the sprites for the passenger wagon when used with this engine
// Loading sprites with open doors
spriteset(turbotrain_passenger_loading_set, "src/gfx/turbotrain.png") {
	[142,139,  8,21,   -3,-10]
	[158,139, 20,15,  -13, -7]
	[190,139, 28,10,  -12, -6]
	[238,139, 20,16,   -6, -7]
	[270,139,  8,21,   -3,-10]
	[286,139, 20,15,  -15, -6]
	[318,139, 28,10,  -16, -6]
	[366,139, 20,16,   -6, -7]
}
// Passenger wagon is empty. No people shown
spriteset(turbotrain_passenger_traveling_empty_set, "src/gfx/turbotrain.png") {
	[142,159,  8,21,   -3,-10]
	[158,159, 20,15,  -13, -7]
	[190,159, 28,10,  -12, -6]
	[238,159, 20,16,   -6, -7]
	[270,159,  8,21,   -3,-10]
	[286,159, 20,15,  -15, -6]
	[318,159, 28,10,  -16, -6]
	[366,159, 20,16,   -6, -7]
}
// Passenger wagon is full. Show people through the window
spriteset(turbotrain_passenger_traveling_full_set, "src/gfx/turbotrain.png") {
	[142,159,  8,21,   -3,-10]
	[158,159, 20,15,  -13, -7]
	[190,159, 28,10,  -12, -6]
	[238,159, 20,16,   -6, -7]
	[270,159,  8,21,   -3,-10]
	[286,159, 20,15,  -15, -6]
	[318,159, 28,10,  -16, -6]
	[366,159, 20,16,   -6, -7]
}

// Associate graphics with the engine for the different loading stages
spritegroup turbotrain_engine_group {
	loading: turbotrain_engine_set;
	loaded: turbotrain_engine_set;
}
// Associate graphics with the wagon for the different loading stages
spritegroup turbotrain_passenger_group {
	loading: turbotrain_passenger_set;
	loaded: [turbotrain_passenger_traveling_empty_set, turbotrain_passenger_traveling_full_set];
}

// Define new graphics for the turbotrain (it has vehicleID 20):
item(FEAT_TRAINS, turbotrain, 20) {
	property {
		sprite_id:                    SPRITE_ID_NEW_TRAIN;    // We have our own sprites
		misc_flags:                   bitmask(TRAIN_FLAG_MU); // We use special sprites for passenger and mail wagons
	}
	graphics {                           // graphics for engine
		turbotrain_engine_group;
	}
	livery_override(passenger_wagon) {   // graphics for alternative look of passenger wagon when used with this engine
		turbotrain_passenger_group;
	}
}
</pre>


<h3><a name="block-spritegroup-vehicles">Spritegroups for railtypes</a></h3>
Only the block_name <code>default</code> is used and it only takes one spriteset.
<pre class="code">
spritegroup gui_normal_modern_TTD_group {
	default: gui_normal_modern_TTD;
}
</pre>
<h3><a name="block-spritegroup-vehicles">Spritegroups for airport tiles</a></h3>
<pre class="code">
A simple example to illustrate how it works:
spritegroup airport_building1 {
	ground { ttdsprite: GROUNDSPRITE_NORMAL; }
	childsprite { 
		sprite: spr_small_dirt_ne;
		always_draw: 1;
	}
	building {
		ttdsprite: 0xA67; // reuse this existing base set sprite
		xoffset: 0x0F;
		xextent: 1;
		zextent: 6;
		recolor: 0;
	}
}
</pre>

<h2><a name="block-switch">Switch</a></h2>
<pre class="exl">switch (&lt;expression&gt;, (SELF|PARENT), &lt;ID&gt;, &lt;expression&gt;) {
	(&lt;range&gt;: &lt;return_value&gt;;)*
	&lt;return_value&gt;;
}</pre>
<p>The four parameters have the following meaning:</p>
<ul>
<li><code>&lt;expression&gt;</code>: The feature for which this switch is used
(see <a href="#structure-features">Features</a>).</li>
<li><code>(SELF|PARENT)</code>Which variables to use. SELF uses the variables
of the item itself, while PARENT uses the variables of a related object. This
related object differs per feature, refer to the table below.</li>
<li><code>&lt;ID&gt;</code>Name of this switch block. This (unique) name can
be used to refer to the block from other switch- or graphics-blocks.</li>
<li><code>&lt;expression&gt;</code>The expression that will be evaluated
to make a decision. This expression may contain variables.</li>
</ul>
<table class="t">
<tr><th>Feature<th>SELF<th>PARENT
<tr><td>FEAT_TRAINS<td>Engine / wagon / articulated part itself<td>Front engine
<tr><td>FEAT_ROADVEHS<td>Road vehicle part<td>First road vehicle part
<tr><td>FEAT_SHIPS<td>Ship<td>Ship
<tr><td>FEAT_AIRCRAFT<td>Aircraft (a)<td>Aircraft
<tr><td>FEAT_STATIONS<td>Station tile<td>Town
<tr><td>FEAT_CANALS<td>Canal tile<td>N/A
<tr><td>FEAT_BRIDGES<td>Bridge<td>Town
<tr><td>FEAT_HOUSES<td>House tile<td>Town
<tr><td>FEAT_GLOBALVARS<td>N/A<td>N/A
<tr><td>FEAT_INDUSTRYTILES<td>Industry tile<td>Industry to which the tile belongs
<tr><td>FEAT_INDUSTRIES<td>Industry<td>Town
<tr><td>FEAT_CARGOS<td>Cargo type<td>N/A
<tr><td>FEAT_SOUNDEFFECTS<td>N/A<td>N/A
<tr><td>FEAT_AIRPORTS<td>Airport<td>N/A
<tr><td>FEAT_SIGNALS<td>N/A<td>N/A
<tr><td>FEAT_OBJECTS<td>Object tile<td>Town
<tr><td>FEAT_RAILTYPES<td>Rail tile<td>N/A
<tr><td>FEAT_AIRPORTTILES<td>Airport tile<td>Airport
</table>
<p>(a) Except for mail capacity callbacks, where it refers to the mail compartment.
To refer to the aircraft itself, use PARENT scope there.</p>

<p><code>&lt;range&gt;</code> can either be a single number or two numbers separated by
two dots. In the first case, the range matches if the result of the computation is
equal to the supplied value. If a range (<code>a .. b</code>) is supplied, it matches
if the computed result is within that range. If several lines of the switch block match
the expression being tested the first applicable result will be returned.</p>
<p>Possible values for <code>&lt;return_value&gt;</code>e are the following:</p>
<ul>
<li><code>&lt;ID&gt;;</code> chains to the (random-)switch or spritegroup with the given ID.</li>
<li><code>return (&lt;expression&gt;|&lt;string&gt;);</code> returns the given expression or
string as a result of the callback.</li>
<li><code>return;</code> returns the computed value directly as a callback result. Note that
the maximum value for callback results is 32511 (0x7EFF).</li>
<li><code>CB_FAILED;</code> stops processing and returns an explicit failure code.</li>
</ul>

<p>Some example code is given below. Note that the code does not have an actual
meaning, it is merely meant to demonstrate all the various options available.</p>
<pre class="code">
switch (FEAT_TRAINS, PARENT, some_vehicle_switch, (position_in_consist + param[1]) % 4) {
	0..2: return string(STRING_FOO_BAR); //return a text message
	3: return; //return the computed value
	5...300: return 42; //42 is always a good answer
	400: other_switch; //chain to some other switch block
	CB_FAILED; //return a failure result
}
</pre>
<h2><a name="block-randomswitch">Random switch</a></h2>
<p>While a <a href="#block-switch">switch-block</a> allows making a predictable
decision, a random_switch allows a randomised choice between several options.</p>
<pre class="exl">random_switch (&lt;feature&gt;, &lt;type&gt;, &lt;ID&gt;[, &lt;triggers&gt;]) {
	(&lt;independent&gt;: &lt;other_random&gt;;)*
	(&lt;dependent&gt;: &lt;other_random&gt;;)*
	(&lt;probability&gt;: &lt;return_value&gt;;)+
}</pre>
<p>The first parameter <code>&lt;feature&gt;</code> specifies the feature to use.
<code>&lt;type&gt;</code>, the second parameter, is used to define what random data
is used. The supported combinations are listed in the following table. The amount
of random data is given in the third column. The maximum number of possible
combinations is equal to 2^x, with x being the number of random bits. The last
column specifies the object of which the random data is used.</p>

<table class="t">
<tr><th>Feature</th><th>Type</th><th># of random bits</th><th>Random data used</th></tr>
<tr><td>Vehicles</td><td>SELF</td><td>8</td><td>Vehicle itself</td></tr>
<tr><td>Vehicles</td><td>PARENT</td><td>8</td><td>Leading engine</td></tr>
<tr><td>Vehicles</td><td>BACKWARD_SELF(x)</td><td>8</td><td>Count x vehicles backward (away from the engine), starting at the vehicle itself (a)</td></tr>
<tr><td>Vehicles</td><td>FORWARD_SELF(x)</td><td>8</td><td>Count x vehicles forward (towards the engine), starting at the vehicle itself (a)</td></tr>
<tr><td>Vehicles</td><td>BACKWARD_ENGINE(x)</td><td>8</td><td>Count x vehicles backward, starting at the leading engine (a)</td></tr>
<tr><td>Vehicles</td><td>BACKWARD_SAMEID(x)</td><td>8</td><td>Count x vehicles backward, starting at the first vehicle in the chain with the same ID (a)</td></tr>
<tr><td>Stations / airport tiles</td><td>SELF</td><td>16</td><td>Station</td></tr>
<tr><td>Stations / airport tiles</td><td>TILE</td><td>4</td><td>Specific station tile</td></tr>
<tr><td>Canals</td><td>SELF</td><td>8</td><td>Canal tile</td></tr>
<tr><td>Houses</td><td>SELF</td><td>8</td><td>House tile (b)</td></tr>
<tr><td>Industry tiles</td><td>SELF</td><td>8</td><td>Industry tile</td></tr>
<tr><td>Industry tiles</td><td>PARENT</td><td>16</td><td>Industry as a whole</td></tr>
<tr><td>Industries</td><td>SELF</td><td>16</td><td>Industry (same as above)</td></tr>
<tr><td>Objects</td><td>SELF</td><td>8</td><td>Object tile (different per tile)</td></tr>
<tr><td>Rail types</td><td>SELF</td><td>2</td><td>Rail tile (pseudo-random, based on location)</td></tr>
</table>
<p>(a) x can be any expression. It can even contain variables, in that case
the variables of the vehicle itself are used.</p>
<p>(b) The random bits are initially the same for all tiles of a multi-tile house.</p>
<p>The third parameter <code>&lt;ID&gt;</code> can be used to refer to this
block from other (random-)switch-blocks. The last parameter
<code>&lt;triggers&gt;</code> is optional and allows re-randomizing when
certain conditions occur. The events and accompanying trigger names are
given in the following tables. To re-randomize graphics when any of a set of
events occurs, use <code>bitmask(TRIGGER_A, TRIGGER_B, .. , TRIGGER_Z)</code>
To re-randomize only when <em>all</em> of the events have occured, add <code>TRIGGER_ALL_NEEDED</code>
to the list of used triggers, e.g. use <code>bitmask(TRIGGER_ALL_NEEDED, TRIGGER_A, ...)</code></p>

<table class="t">
<caption>Vehicle triggers</caption>
<tr><th>Trigger</th><th>Event</th></tr>
<tr><td>TRIGGER_VEHICLE_NEW_LOAD</td><td>Vehicle gets new load of cargo (only after it was empty)</td></tr>
<tr><td>TRIGGER_VEHICLE_SERVICE</td><td>Vehicle enters a depot and is serviced</td></tr>
<tr><td>TRIGGER_VEHICLE_UNLOAD_ALL</td><td>The consist has unloaded all cargo (use with type 'SELF')</td></tr>
<tr><td>TRIGGER_VEHICLE_ANY_LOAD</td><td>Any vehicle of the consist receives cargo (use with type 'SELF')</td></tr>
<tr><td>TRIGGER_VEHICLE_32_CALLBACK</td><td>32-day callback returned 1</td></tr>
</table>
<p>To re-randomize when the consist has been emptied and then receives new cargo, use
<code>bitmask(TRIGGER_VEHICLE_UNLOAD_ALL, TRIGGER_VEHICLE_ANY_LOAD, TRIGGER_ALL_NEEDED)</code></p>

<table class="t">
<caption>Station triggers</caption>
<tr><th>Trigger</th><th>Event</th></tr>
<tr><td>TRIGGER_STATION_NEW_CARGO</td><td>New cargo waiting</td></tr>
<tr><td>TRIGGER_STATION_NO_MORE_CARGO</td><td>No more cargo waiting</td></tr>
<tr><td>TRIGGER_STATION_TRAIN_ARRIVES</td><td>Train arrives (starts loading/unloading)</td></tr>
<tr><td>TRIGGER_STATION_TRAIN_LEAVES</td><td>Train leaves (done loading/unloading)</td></tr>
<tr><td>TRIGGER_STATION_TRAIN_LOADS_UNLOADS</td><td>Train loads/unloads cargo</td></tr>
<tr><td>TRIGGER_STATION_TRAIN_RESERVES</td><td>Train reserves platform using PBS</td></tr>
</table>
<p>The last four triggers in the table only trigger on the platform on which they occur.</p>

<table class="t">
<caption>House triggers</caption>
<tr><th>Trigger</th><th>Event</th></tr>
<tr><td>TRIGGER_HOUSE_TILELOOP</td><td>The house tile is processed in the periodic tile-processing loop</td></tr>
<tr><td>TRIGGER_HOUSE_TOP_TILELOOP</td><td>The top tile of the house is processed in the periodic tile-processing loop</td></tr>
</table>
<p>Using <code>TRIGGER_HOUSE_TOP_TILELOOP</code>, it is possible to re-randomize
the whole building as one unit. All tiles of a multi-tile house will get the same
new random data.</p>

<table class="t">
<caption>Industry tile triggers</caption>
<tr><th>Trigger</th><th>Event</th></tr>
<tr><td>TRIGGER_INDUSTRYTILE_TILELOOP</td><td>The industry tile is processed in the periodic tile-processing loop </td></tr>
<tr><td>TRIGGER_INDUSTRYTILE_256_TICKS</td><td>Triggers simultaneously for all tiles of the industry every 256 ticks.
If the industry is a primary one, output cargo is generated at the same time.</td></tr>
<tr><td>TRIGGER_INDUSTRYTILE_CARGO_DELIVERY</td><td>Cargo is delivered to the industry. If the industry is a processing one, output cargo is generated at the same time.</td></tr>
</table>

<p><code>&lt;independent&gt;: &lt;other_random&gt;;</code> makes sure that this
random_switch block and <code>&lt;other_random&gt;</code> use different
(non-intersecting) random data. This allows making multiple randomized
decisions that are independent of each other.</p>
<p><code>&lt;dependent&gt;: &lt;other_random&gt;;</code>, on the other hand,
lets this random_switch block and <code>&lt;other_random&gt;</code> use the same
random data. To make this possible, it should not require more random data
(i.e. have a higher sum of probabilities) than the block it is dependent on.</p>
<p>Both of these options require enough random data to be available. Also, the
combination must make sense. For example, if A is dependent on B and B is
dependent on C, then A cannot be independent of C.</p>
<p>Following this, there is a list of options, one of which will be chosen
randomly. The syntax is <code>&lt;probability&gt;: &lt;return_value&gt;;</code>.
The relative probability that this option will be chosen is given by
<code>&lt;probability&gt;</code>. The chance is equal to the probability divided
by the sum of all probabilities. If this sum is not equal to a power of two (2,
4, 8, 16, ...), then rounding is done and the probabilities may be inexact. For
information about <code>&lt;return_value&gt;</code>, see the
<a href="#block-switch">switch-block</a>. Let's conclude with an example:
<pre class="code">random_switch (FEAT_TRAINS, SELF, random_42, bitmask(TRIGGER_VEHICLE_UNLOAD_ALL, TRIGGER_VEHICLE_ANY_LOAD, TRIGGER_ALL_NEEDED)) {
	/* re-randomize when vehicle has been emptied and then received new cargo */
	independent: random_43; // decision should be independent from random_43, which is defined elsewhere
	6: group_open;          // 6/11 chance to display open wagon
	3: group_closed;        // 3/11 chance to display closed wagon (with cover)
	2: group_halfopen;      // 2/11 chance to display a half-covered wagon
}</pre>

<h2><a name="block-template">Template</a></h2>

<h2><a name="block-cargotable">Cargotable</a></h2>
<pre class="exl">cargotable {
	ID [, ID]*
}</pre>
<p>The cargotable is a list of 4-byte long IDs. For example:</p>
<pre class="code">cargotable {
	PASS, MAIL, GOOD, COAL
}</pre>

<h2><a name="block-if">If/else</a></h2>
<pre class="exl">
if (expression) {
	block;
} else {
	block;
}
</pre>
<p>For example:</p>
<pre class="code">
if (param[1] == 1) {
	param[2] = 3
} else {
	param[2] = 5
}
</pre>

<h2><a name="block-while">While</a></h2>

<h2><a name="block-error">Error</a></h2>
<p>The general form of an error statement is:</p>
<pre class="exl">
error(level, message[, extra_text[, parameter1[, parameter2]]])
</pre>
<p>where level is the severity of the message and one of <code>NOTICE, WARNING, ERROR, FATAL</code>. The message can be either a custom
defined string which can contain up to two parameters or it can be one of the pre-defined strings which already have translations. The first
{STRING}-code will always be replaced by the NewGRF name. The second {STRING}-code will be replaced by the value of 'extra_text'. Extra_text
can be a string defined in the language files or it can be a literal string, in which case it cannot be translated. You should only use a
literal string in those cases where you are sure it doesn't have to be translated, for example to provide a version string like "0.7.0".
<table class="t">
<tr><th>name <th>actual text<th>Contents of extra_text
<tr><td>REQUIRES_TTDPATCH <td>"{STRING} requires at least TTDPatch version {STRING}"<td>version string
<tr><td>REQUIRES_DOS_WINDOWS <td>"{STRING} is for the {STRING} version of TTD."<td>[DOS | Windows]
Palette type
<tr><td>USED_WITH <td>"{STRING} is designed to be used with {STRING}"<td>switchname + value, e.g. "multihead 0". This is designed to be used
for incompatible settings that you can check via ttdpatch_flags.
<tr><td>INVALID_PARAMETER <td>"Invalid parameter for {STRING}: parameter {STRING} ({PARAM})"<td>extra_text should be the parameter number written
out as string. {PARAM} is replaced by parameter1.
filled in.
<tr><td>MUST_LOAD_BEFORE <td>"{STRING} must be loaded before {STRING}."<td>NewGRF name
<tr><td>MUST_LOAD_AFTER <td>"{STRING} must be loaded after {STRING}."<td>NewGRF name
<tr><td>REQUIRES_OPENTTD <td>"{STRING} requires OpenTTD version {STRING} or better."<td>version string
<tr><td>string(STR_MY_ERROR_MESSAGE)<td>(user-defined string)<td>The message-string can use the code {STRING} up to 2 times, the first usage will be replaced by the
NewGRF name and the second usage by 'extra_text'. After 2 {STRING}-codes you can include up to 2 {PARAM}-codes that will be replaced
by the contents of parameter1 and parameter2.
</table>

For example:
<pre class="code">
error(NOTICE, USED_WITH, string(STR_REGRESSION_CARE));
error(FATAL, string(STR_REGRESSION_ERROR), string(STR_ANSWER), 14, param[1] + 12 * param[2]);
</pre>
<h2><a name="block-deactivate">Deactivate</a></h2>

<h2><a name="block-replacement">Sprite replacement</a></h2>
<p>This section covers the three available methods to replace sprites.
Which one to use depends on the type of sprites you want to replace. The following
sections will outline the detailed functionality of these blocks and when to use them.</p>

<h3><a name="block-replacement-replace">Replace TTD sprites</a></h3>
<p>Using a <code>replace</code> block, it is possible to replace TTD's built-in sprites.
The syntax is as follows:</p>
<pre class="exl">replace(&lt;sprite-id&gt;, &lt;image-file&gt;) {
	&lt;real-sprites&gt;...
}</pre>
<p>The first parameter <code>&lt;sprite-id&gt;</code> indicates the sprite number of the
first sprite to replace. Sprite numbers are equal to the sprite numbers in the base graphics file. The
<a href="http://mz.openttdcoop.org/opengfx/authors/script.php?feature=spritesbyfile&amp;q=ogfx1_base">
OpenGFX author overview</a> can be used as a reference to look up these sprite numbers.
The second parameter <code>&lt;image-file&gt;</code> specifies the image file that contains
the new sprites. A series of real sprites has to be specified between the curly braces
(<code>{</code> and <code>}</code>). The first sprite in this list replaces the sprite with id
<code>sprite-id</code>, the second replaces <code>sprite-id + 1</code> and so on.
Sprite templates can be used as well. For example:</p>
<pre class="code">
// Rail overlays for crossings
replace (1005, "src/gfx/rails_overlays.png") {
		[ 20,198, 40,21, -20,  5]
		[ 71,198, 40,21, -20,  5]
		[117,198, 40, 7, -20,  5]
		[165,198, 40, 7, -20, 21]
		[216,198, 12,19,  10,  5]
		[248,198, 12,19, -24, 11]
}
</pre>

<h3><a name="block-replacement-replacenew">Replace new sprites</a></h3>
<p>Over time, several features have been added to TTDPatch and OpenTTD that require new
sprites. As these sprites are not present in the original base graphics, they cannot
be replaced using a normal <code>replace</code> block. Instead, a <code>replacenew</code>
block has to be used. The semantics are like this:</p>
<pre class="exl">replacenew(&lt;type&gt;, &lt;image-file&gt;[, &lt;offset&gt;]) {
	&lt;real-sprites&gt;...
}</pre>
<p>The <code>&lt;type&gt;</code> parameter indicates the type of sprites that will
be replaced. It should be an identifier from the first column of the following table.</p>

<!-- This table could use some information regarding versioning, descriptions
 and references to which sprites are actually needed. However this is a lot
 of work (even TTDP wiki doesn't list all info) and this is not really a
 high priority job -->
<table class="t">
	<tr><th>Type</th><th>Number of sprites</th></tr>
	<tr><td>PRE_SIGNAL</td><td>48</td></tr>
	<tr><td>PRE_SIGNAL_SEMAPHORE</td><td>112</td></tr>
	<tr><td>PRE_SIGNAL_SEMAPHORE_PBS</td><td>240</td></tr>
	<tr><td>CATENARY</td><td>48</td></tr>
	<tr><td>FOUNDATIONS_SLOPES</td><td>74</td></tr>
	<tr><td>FOUNDATIONS_SLOPES_HALFTILES</td><td>90</td></tr>
	<tr><td>TTDP_GUI_25</td><td>73</td></tr>
	<tr><td>TTDP_GUI</td><td>93</td></tr>
	<tr><td>CANALS</td><td>65</td></tr>
	<tr><td>ONE_WAY_ROAD</td><td>6</td></tr>
	<tr><td>COLORMAP_2CC</td><td>256</td></tr>
	<tr><td>TRAMWAY</td><td>113</td></tr>
	<tr><td>SNOWY_TEMPERATE_TREES</td><td>133</td></tr>
	<tr><td>COAST_TILES</td><td>16</td></tr>
	<tr><td>COAST_TILES_BASEGFX</td><td>10</td></tr>
	<tr><td>COAST_TILES_DIAGONAL</td><td>18</td></tr>
	<tr><td>NEW_SIGNALS</td><td>any (a)</td></tr>
	<tr><td>SLOPED_RAILS</td><td>12</td></tr>
	<tr><td>AIRPORTS</td><td>15</td></tr>
	<tr><td>ROAD_STOPS</td><td>8</td></tr>
	<tr><td>AQUEDUCTS</td><td>8</td></tr>
	<tr><td>AUTORAIL</td><td>55</td></tr>
	<tr><td>FLAGS</td><td>36 (b)</td></tr>
	<tr><td>OTTD_GUI</td><td>154 (b)</td></tr>
	<tr><td>AIRPORT_PREVIEW</td><td>9 (b)</td></tr>
</table>

<p>(a) Any number of sprites is allowed here, however both OpenTTD and
NML don't (yet) support the other features required to use these sprites.</p>

<p>(b) Any number of sprites can be specified up to the stated maximum.
Furthermore the <code>offset</code> variable can be used, see below for
more info.</p>

<p>The amount of sprites has to be
equal to the number given in the table, except in the cases of (a) and (b).
Having less sprites results in an error. Having more sprites is allowed
to provide future compatibility, but a warning will be issued.</p>

<p>Parameter two <code>&lt;image-file&gt;</code> is a literal (quoted) string
that specifies the file where the sprites are located.</p>
<p>Parameter <code>&lt;offset&gt;</code> is optional and has a default value of 0.
Values greater than zero are only allowed in the case of the sprite types marked
with (b). Setting this value sets an offset into the block of sprites, so only a
subset of the sprites (starting at <code>offset</code>) will be replaced.</p>

<h3><a name="block-replacement-fontglpyh">Add font glpyhs</a></h3>
<p>A <code>font-glpyh</code> block makes it possible to provide sprites
for glyphs that don't have sprites in normal TTD. The syntax is as follows:</p>

<pre class="exl">font_glpyh (&lt;font-size&gt;, &lt;base-char&gt;, &lt;image-file&gt;) {
	&lt;real-sprites&gt;...
}</pre>

<p>The first parameter (<code>&lt;font-size&gt;</code>) should be an identifier
of the font size to use. Valid values are <code>SMALL</code>, <code>NORMAL</code>
and <code>LARGE</code>.</p>
<p>The second parameter (<code>&lt;base-char&gt;</code>) is the number
corresponding to the first character to provide a sprite for. Valid values are
all unicode code points in the Basic Multilingual Plane (0-0xFFFF)</p>
<p>Parameter three <code>&lt;image-file&gt;</code> is a literal (quoted) string
that specifies the file where the sprites are located.</p>
<p><code>&lt;real-sprites&gt;</code> should be a list of real sprites. The first
real sprite will be used for the character with code <code>base-char;</code>, the
second for <code>base-char + 1</code> and so on. These sprites should only use
color palette indices 0 (transparent), 1 (foreground), and 2 (shadow). If the
shadow color is used, sprite compression flag 'TILE' must NOT be set.</p>

<h2><a name="block-town_names">Town names</a></h2>
<p>To define randomly generated town names, the <tt>town_names</tt> block should
be used. Such blocks can be used in two ways, as generator of (partial) town
names for another block, or as top-level town names block, a starting point
of town names in the
grf file. You must have at least one starting point, but you can have more
than one.</p>
<p>The general syntax of a town names block is:</p>
<pre class="exl">town_names[(&lt;name&gt;)] {
	[styles : &lt;string&gt;]
	&lt;part&gt; &lt;part&gt; ....
}</pre>
<p>The optional <code>&lt;name&gt;</code> defines the name of the block. Such a
name is used to refer to this block from another town names block.
For top-level town names blocks, it is often left out. Note that in that case,
you must also leave out the parentheses.</p>
<p>The optional <code>&lt;string&gt;</code> defines how the town names are
called in the menu. It may only be defined in a top-names block. To make the
name available in all languages, it is probably a good idea to at least define
a menu name for the generic language.</p>

<h3><a name="block-town_names-parts">Town names parts</a></h3>
<p>A <code>town_names</code> block has one or more <code>&lt;part&gt;</code>s.
Each part defines a piece of a town name. All pieces together form the name
generated by the block.</p>
<p>An example of a part is:</p>
<pre class="code">{
	text("name1", 1),
	text("name2", 2),
	town_names(othernames, 3)
}</pre>
<p>The simplest form is just a list of <code>text(...)</code>entries.
Each entry contains a possible value of piece, and a probability of picking
that name. The <code>town_names(&lt;name&gt;, &lt;probability&gt;)</code>calls
a previous <code>town_names</code> block (called 'othernames' in the example),
and returns the value generated there.
A part should have at least one. At least up to 255 entries will always work.
If a part contains even more entries, NML tries to make it fit by creating
sub-blocks. If that fails, you will get an error.</p>
<p>The numbers are the probabilities. In the example, the sum of all values is
6, which means that <code>name1</code> is picked with 1/6 chance,
<code>name2</code> has a 2/6 chance, and a name generated from the previous
<code>town_names</code> block has a 3/6 chance.</p>


<h2><a name="block-assignment">Parameter assignment</a></h2>
<pre class="exl">param[&lt;expression&gt;] = &lt;expression&gt;;</pre>
<p>Set a parameter to the given expression. Neither of the two expressions has
to be constant, the following is perfectly valid:</p>
<pre class="code">param[param[2] + 1] = param[3] * param[4];</pre>

<h2><a name="block-sounds">Sound support</a></h2>
<p>Sounds are supported by means of the <code>sounds</code> block.
An example of a sounds block that defines two new sounds is:</p>
<pre class="code">sounds {
	load_soundfile("whistle.wav");
	import_sound(0x87654321, 3);
}</pre>
<p>The block starts with the keyword <code>sounds</code>, followed by one
or more sound definitions. A sound definition either loads a sound file (like
the <code>load_soundfile("whistle.wav");</code> which includes the
<i>whistle.wav</i> file), or it refers to a sound from another NewGRF file
(like the <code>import_sound(0x87654321, 3);</code> which imports the fourth
sound (index 3) from the NewGRF file with ID <code>0x87654321</code>). Importing sounds
does not make copies of the data, thus saving memory space.</p>
<p>You can have at most one <code>sounds</code> block in a NewGRF file. When
using a sound from a sound block, the first sound gets number <code>73</code>,
the second sound gets number <code>74</code>, and so on. Note that this is
different from the numbering that you use when importing a sound from
another NewGRF, as counting starts at <code>0</code> in that case.</p>
<p>All loaded sound files must be
8-bit mono sound files in WAV format, PCM encoding. There are two allowed
frequencies: 11025 Hz and 22050 Hz. Due to some limitations of the NewGRF format,
the file size cannot exceed 64KB.</p>
<h2><a name="block-basecost">Setting base costs</a></h2>
<p>A number of base costs define how much everything costs in (O)TTD(P).
Each cost in-game is determined by a fixed factor multiplied by a base cost.
Setting base cost to 0 leaves this cost unchanged. Incrementing it by one
doubles the cost, so e.g. a setting of 3 results in a cost that is 8x higher.
Setting a negative value reduces the cost in the same manner, e.g. a value of
-4 results in 1/16th of the cost. The minimum and maximum values are -8 (1/256th)
and 16 (65536x), respectively. Some example code:</p>
<pre class="code">
basecost {
	PR_BUILD_TUNNEL: 2;   // tunnel cost x4
	PR_BUILD_BRIDGE: -3;  // bridge cost x1/8
	PR_RUNNING: param[1]; // all running costs are set by the factor in grf parameter 1
	param[2]: param[3];   // base cost with the number given by param 2 is set to the factor in param 3.
}
</pre>
<p><a href="refs.html#refs-basecost-table">This table</a> lists all base costs that can be set. They can be referred to
using either the number in the first or the identifier in the second column.
Using an identifier from the third column, it is possible to set an entire
category of base costs at once.</p>
<p>Recent OpenTTD versions have added a number of base costs. To keep
compatibility with earlier grfs, a number of 'old' base costs override
the 'new' ones if the 'new' costs are not set separately. These cases are
marked in the table. To avoid this behaviour always set the 'new' cost to 0
if you are changing the 'old' cost but want to keep the new one unchanged.
Note that this may override other grfs that change base costs, but this is
currently unavoidable.</p>

<h1><a name="units">Units</a></h1>

<h1><a name="expressions">Expressions</a></h1>

<h2><a name="elementary-values">Elementary values</a></h2>
Elementary values in expressions are
<table class="t">
<tr><th>Element<th>Syntax (Python RE)<th>Description
<tr><td>Decimal number<td>[0-9]+<td>one or more digits
<tr><td>Hexadecimal number<td>0x[0-9A-Fa-f]+<td>"0x" followed by one or more hexadecimal digits
<tr><td>Floating point number<td>[0-9]+\.[0-9]+<td>a decimal number, a dot, and another decimal number. Only supported for some properties that expect a floating point number.
<tr><td>Identifier<td>[a-zA-Z_][a-zA-Z0-9_]*<td>a letter or underscore, optionally followed by more letters, digits, or underscore characters
<tr><td>String<td>"([^"\\]|\\.)*"<td>A double quote character, followed by zero or more characters, ending with another double quote character. A character in-between is any single character except a double quote or a back-slash ("\"). It can also be "\\", "\n", "\t", or "\[0-9A-Fa-f][0-9A-Fa-f]" (a back-slash followed by exactly two hexadecimal digits).
<tr><td>Setting<td>an Identifier<td>The name of a <a href="#block-grf-settings">GRF setting</a>
<tr><td>Parameter<td>param[<i>&lt;num&gt;</i>]<td>Read/write the parameter with the given number.
<tr><td>Parameter from another GRF<td>param[<i>&lt;grfid&gt;</i>, <i>&lt;num&gt;</i>]<td>Read the value of a parameter of another grf
<tr><td>Unit<td>nfo|mph|km/h|m/s|hp|ton<td>One of the strings "nfo", "mph", "km/h", "m/s", "hp", or "ton" (without quotes). Used to set several properties.
</table>

You can combine those elementary values using operators like you're used to from other languages. The following operators are supported:
+, -, *, /, %, &, |, ^, &&, ||, <<, >>, ==, !=, &lt;=, &gt;=, &lt;, &gt;

<h2><a name="builtin-functions">Builtin functions</a></h2>
Available builtin functions are
<table class="t">
<tr><th>Function<th>Description
<tr><td>min(<i>v1</i>, <i>v2</i>)<td>Return the smallest value
<tr><td>max(<i>v1</i>, <i>v2</i>)<td>Return the biggest value
<tr><td>date(<i>year</i>, <i>month</i>, <i>day</i>)<td>If all values are constants, returns
the number of days since year 0. If the year is a variable, the month and day should be 1.
<tr><td>day_of_year(<i>month</i>, <i>day</i>)<td>Return the day of the year
since January 1st. Both values must be compile-time constants.
<tr><td>bitmask(<i>bitpos1</i>, ...)<td>Compose an integer by switching the bits at the given positions on.
<tr><td>STORE_TEMP(<i>value</i>, <i>address</i>)<td>Store value in temporary storage
<tr><td>STORE_PERM(<i>value</i>, <i>address</i>)<td>Store value in permanent storage
<tr><td>LOAD_TEMP(<i>address</i>)<td>Get value from temporary storage
<tr><td>LOAD_PERM(<i>address</i>)<td>Get value from permanent storage
<tr><td>hasbit(<i>value</i>, <i>bit_num</i>)<td>Test whether a bit in a value is on
<tr><td>version_openttd(<i>major</i>, <i>minor</i>, <i>revision</i>[, <i>build</i>])<td>Return
the constant representing an OpenTTD version
<tr><td>cargotype_available(<i>cargotype</i>)<td>Check if a certain cargo type is available in
this game. <i>cargotype</i> must be a literal string of length 4.
<tr><td>railtype_available(<i>railtype</i>)<td>Check if a railtype is available in this game. 
<i>railtype</i> must be a literal string of length 4.
<tr><td>grf_current_status(<i>grfid[, mask]</i>)<td>1 if the given GRF is currently active 0, otherwise.
If <i>mask</i> is set, only the bits set in the mask will be tested. Both parameters must be a literal string
of length 4.
<tr><td>grf_future_status(<i>grfid[, mask]</i>)<td>Same as above, but tests whether the grf
will become active instead of whether it's currently active.
<tr><td>visual_effect_and_powered(<i>effect</i>, <i>offset</i>, <i>powered</i><td>Helper function for the train
property visual_effect_and_powered and the VEH_CB_VISUAL_EFFECT_AND_POWERED callback.
</table>

</body>
</html>
