<html>
<head>
<title>NML documentation</title>
<link rel="stylesheet" title="Standard Style" type="text/css" href="nml.css">
</head>
<body>

<h1>Contents</h1>
<ul>
<li><a href="#preface">Preface</a></li>
<li><a href="#structure">Language structure</a></li>
<li><a href="#block-syntax">Block syntax</a>
<ul>
	<li><a href="#block-grf">GRF</a></li>
	<li><a href="#block-item">Item</a>
		<ul>
			<li><a href="#block-item-property">Property</a></li>
			<li><a href="#block-item-graphics">Graphics</a></li>
			<li><a href="#block-item-livery_override">Livery override</a></li>
		</ul>
	</li>
	<li><a href="#block-spriteblock">Spriteblock</a>
		<ul>
			<li><a href="#block-spriteblock-spriteset">Spriteset</a></li>
			<li><a href="#block-spriteblock-spritegroup">Spritegroup</a></li>
		</ul>
	</li>
	<li><a href="#block-switch">Switch</a></li>
	<li><a href="#block-randomswitch">Random switch</a></li>
	<li><a href="#block-template">Template</a></li>
	<li><a href="#block-cargotable">Cargotable</a></li>
	<li><a href="#block-if">If/else</a></li>
	<li><a href="#block-while">While</a></li>
	<li><a href="#block-error">Error</a></li>
	<li><a href="#block-deactivate">Deactivate</a></li>
	<li><a href="#block-replacement">Sprite replacement</a>
		<ul>
			<li><a href="#block-replacement-replace">Replace TTD sprites</a></li>
			<li><a href="#block-replacement-replacenew">Replace new sprites</a></li>
			<li><a href="#block-replacement-fontglpyh">Add font glpyhs</a></li>
		</ul>
	</li>
	<li><a href="#block-town_names">Town names</a>
		<ul>
			<li><a href="#block-town_names-parts">Town names parts</a></li>
		</ul>
	</li>
	<li><a href="#block-assignment">Parameter assignment</a></li>
	<li><a href="#block-sounds">Sound support</a></li>
</ul>
</li>
<li><a href="#units">Units</a></li>
<li><a href="#expressions">Expressions</a></li>
<ul>
	<li><a href="#elementary-values">Elementary values</a></li>
	<li><a href="#builtin-functions">Builtin functions</a></li>
</ul>
<li><a href="#language-files">Language files</a></li>
<li><a href="#properties">List of properties</a>
<ul>
	<li><a href="#property-trains">Trains</a></li>
	<li><a href="#property-roadvehs">Road vehicles</a></li>
	<li><a href="#property-ships">Ships</a></li>
	<li><a href="#property-planes">Planes</a></li>
	<li><a href="#property-stations">Stations</a></li>
	<li><a href="#property-canals">Canals</a></li>
	<li><a href="#property-bridges">Bridges</a></li>
	<li><a href="#property-houses">Houses</a></li>
	<li><a href="#property-industrytiles">Industry tiles</a></li>
	<li><a href="#property-industries">Industries</a></li>
	<li><a href="#property-cargos">Cargos</a></li>
	<li><a href="#property-airports">Airports</a></li>
	<li><a href="#property-railtypes">Railtypes</a></li>
	<li><a href="#property-airporttiles">Airport tiles</a></li>
	<li><a href="#property-snowline">Snowline</a></li>
</ul>
</li>
<li><a href="#vars">List of variables</a>
<ul>
	<li><a href="#vars-trains">Trains</a></li>
	<li><a href="#vars-roadvehs">Road vehicles</a></li>
	<li><a href="#vars-ships">Ships</a></li>
	<li><a href="#vars-planes">Planes</a></li>
	<li><a href="#vars-stations">Stations</a></li>
	<li><a href="#vars-canals">Canals</a></li>
	<li><a href="#vars-bridges">Bridges</a></li>
	<li><a href="#vars-houses">Houses</a></li>
	<li><a href="#vars-industrytiles">Industry tiles</a></li>
	<li><a href="#vars-industries">Industries</a></li>
	<li><a href="#vars-cargos">Cargos</a></li>
	<li><a href="#vars-airports">Airports</a></li>
	<li><a href="#vars-railtypes">Railtypes</a></li>
	<li><a href="#vars-airporttiles">Airport tiles</a></li>
</ul>
</li>
</ul>

<h1><a name="preface">Preface</a></h1>
<p>NewGRF files are files containing sprites and pseudo-sprites that can be
used to describe extra vehicles, industries, cargoes etc. for use in OpenTTD
and TTDPatch. The most used tool to encode/decode GRF flies is
<a href="http://www.ttdpatch.net/grfcodec/">GRFCodec</a>
(<a href="http://www.openttd.org/download-grfcodec">nightly download</a>).
GRFCodec can read NFO files and convert them to GRF files
(<a href="http://www.ttdpatch.net/grfcodec/grf.html">GRF file format</a>).
NFO is a low-level language that is tied to the GRF spec. It uses hexadecimal
numbers by default in most places and doesn't have any textual identifiers.
While the language is very powerful, it's also hard to learn. NML was started
mainly to provide a higher level language so coding GRF files will become
accessable to more people.</p>

<h1><a name="structure">Language structure</a></h1>
<h2>Blocks</h2>
<p>NML files are mainly composed from blocks. A block starts with the type of
the block, optional arguments and then the contents enclosed by curly braces.
Nearly all NML files will start with a <a href="#block-grf">grf-block</a>. The
grf-block takes no parameters and is one of the simplest blocks there is.
Following is an example grf-block.</p>
<pre class="code">grf {
	grfid : "AB\02\03";
	name : string(STR_GRF_NAME);
	desc : string(STR_GRF_DESCRIPTION);
}</pre>
<p>Let's look at this code line for line.</p>
<pre class="code">grf {</pre>
<p>This block is a grf-block. A grf-block has no parameters. The '{' is the
start of the block content.</p>
<pre class="code">	grfid : "AB\02\03";</pre>
<p>This line sets the grfid of the resulting grf. The value is the letters AB
followed by a byte with value 2 and then another one with value 3. The
semicolon marks the end of the statement.</p>
<pre class="code">	name : string(STR_GRF_NAME);</pre>
<p>The name of the grf. In NML nearly all strings are put in
<a href="#language-files">language files</a>. The format of the language files
is described in another section. For now just assume a string with the name
<code>STR_GRF_NAME</code> exists. To reference a string from the language file
you use <code>string(&lt;stringname&gt;)</code> where <code>&lt;stringname&gt;</code>
should be replaced by the actual name of the string.</p>
<pre class="code">	desc : string(STR_GRF_DESCRIPTION);</pre>
<p>This looks a lot like the previous line, only it sets the description
instead of the name.</p>
<pre class="code">}</pre>
<p>This marks the end of the last-opened block, in this case the grf-block.</p>

<h2>Parameters</h2>
<p>Blocks are not the only item in NML files, you can also do parameter
assignments. Each NewGRF has 128 parameters available, NML reservers the top 64
parameters for internal use. If a user sets parameters for your grf, these are
the starting at parameter 0. Each parameter is available by using
<code>param[&lt;expression&gt;]</code>. You can set parameter number 4 to 3 by doing:
<pre class="code">param[4] = 3;</pre>


<h1><a name="block-syntax">Block syntax</a></h1>
<p>In the next sections you'll often see a word enclosed by the less-than and
greater-than symbols. These words should not be written literally, but instead
a references to another block/item you should use there. The following words
will be used:</p>

<dl>
<dt>&lt;literal-string&gt;</dt>
<dd>A string enclosed by quotes, for example <code>"this is a literal string"</code></dd>

<dt>&lt;string&gt;</dt>
<dd>A string defined in the language file, for example <code>string(STR_GRF_NAME)</code></dd>

<dt>&lt;expression&gt;</dt>
<dd>An expression, this can computation or one of &lt;number&gt;, &lt;float&gt;,
&lt;parameter&gt;, &lt;variable&gt;, &lt;function-call&gt;</dd>

<dt>&lt;ID&gt;</dt>
<dd>The name of an item or block. IDs should start with a letter or underscore.
The rest of the ID may consist of letters, underscores or numbers.</dd>

</dl>
<p>If something is enclosed by square brackes [] it's optional.</p>


<h2><a name="block-grf">GRF</a></h2>
<pre class="exl">grf {
	grfid: &lt;literal-string&gt;;
	name: &lt;string&gt;;
	desc: &lt;string&gt;;
}</pre>
<p>Example:</p>
<pre class="code">grf {
	grfid: "AB\03\02";
	name: string(STR_GRF_NAME);
	desc: string(STR_GRF_DESC);
}</pre>

<h2><a name="block-item">Item</a></h2>
<pre class="exl">item (&lt;expression&gt; [, &lt;ID&gt; [, &lt;expression&gt;]]) {
	(&lt;property-block&gt;|&lt;graphics-block&gt;|&lt;livery_override-block&gt;)+
}</pre>
<p>The first argument is the feature of the item, the second (optional) argument
is the name and the third (optional) argument is the numerical id you want to
use for this item.
Example:</p>
<pre class="code">item (FEAT_ROADVEHS, hereford_tram) {
	property {
		name:               string(STR_NAME_HEREFORD_TRAM);
		climates_available: CLIMATE_ALL;
		introduction_date:  date(1940,1,1);
		speed:              60 km/h;
	}
}</pre>

<h3><a name="block-item-property">Property</a></h3>
<pre class="exl">property {
	(&lt;ID&gt;: (&lt;string&gt;|(&lt;expression&gt; [&lt;unit&gt;]));)+
}</pre>
<p>This one looks a lot more complicated then it actually is. A property-block
contains one or more assignments. Each assignment starts with the name of the
property that is changed followed by a colon. After the colon follow the value
and you end the line with a semicolon. The type of the value depends on the
property, some properties require a string as value and some an expression.
For some properties you can optionally specify a unit that is used to convert
the value to the unit that is written to the output file. You can only use
a unit if the expression is constant. <a href="#units">List of valid units</a></p>

<h3><a name="block-item-graphics">Graphics</a></h3>
<p>In general the layout for defining graphics is like</p>
<pre class="code">
spriteblock(FEATURE) {
	spriteset (SPRITESET_NAME, graphics_file) {
		[left_X, upper_Y, width, height, offset_X, offset_Y]
		...
	}
	spritegroup spritegroup_name {
		loading: spriteset_name
		loaded: spriteset_name
	}
}
</pre>
<p>An example which defines two graphics for a train engine:</p>
<pre class="code">
spriteblock(FEAT_TRAINS) {
	spriteset(turbotrain_engine_set, "sprites/pcx/opengfx_trains_start.pcx") {
		[142,112,  8,22,   -3,-10]
		[158,112, 21,15,  -14, -7]
		[190,112, 31,12,  -16, -8]
		[238,112, 21,16,   -6, -7]
		[270,112,  8,24,   -3,-10]
		[286,112, 21,16,  -15, -6]
		[318,112, 32,12,  -16, -8]
		[366,112, 21,15,   -6, -7]
	}
	spritegroup turbotrain_engine_group {
		loading: turbotrain_engine_set;
		loaded: turbotrain_engine_set;
	}
}
spriteblock(FEAT_TRAINS) {
	spriteset(turbotrain_passenger_set, "sprites/pcx/opengfx_trains_start.pcx") {
		[142,139,  8,21,   -3,-10]
		[158,139, 20,15,  -13, -7]
		[190,139, 28,10,  -12, -6]
		[238,139, 20,16,   -6, -7]
		[270,139,  8,21,   -3,-10]
		[286,139, 20,15,  -15, -6]
		[318,139, 28,10,  -16, -6]
		[366,139, 20,16,   -6, -7]
	}
	spritegroup turbotrain_passenger_group {
		loading: turbotrain_passenger_set;
		loaded: turbotrain_passenger_set;
	}
}
</pre>
<h3><a name="block-item-livery_override">Livery override</a></h3>
<p>A livery override block offers the possibility to change the look of an
engine or wagon depending on wagons coupled to them, e.g. allowing a freight
engine to be differently coloured than a passenger engine. The spritegroup
needs to be defined before it can be used in a livery override. A livery
override block is always part of the engine definition and looks like</p>
<pre class="exl">
livery_override (vehicleID) {
	spritegroup_name
}
</pre>
<p>Concerning this example it is assumed that it is preceeded by the graphics
definitions given as example in the <a href="#block-item-graphics">graphics definition</a>
and that a vehicleID "passenger_wagon" is defined. The engine will get different
looks (spritegroup "turbotrain_passenger_group") in this example, if the passenger
wagon is attached. For all other wagons it will show sprites from "turbotrain_engine_group".</p>
<pre class="code">
// Turbotrain engine:
item(FEAT_TRAINS, turbotrain, 20) {
	property {
		sprite_id:                    SPRITE_ID_NEW_TRAIN;    // We have our own sprites
		misc_flags:                   TRAIN_FLAG_MU;          // We use special sprites for passenger wagons
	}
	graphics {
		turbotrain_engine_group;
	}
	livery_override(passenger_wagon) {
		turbotrain_passenger_group;
	}
}
</pre>
<h2><a name="block-spriteblock">Spriteblock</a></h2>
<h3><a name="block-spriteblock-spriteset">Spriteset</a></h3>
<h3><a name="block-spriteblock-spritegroup">Spritegroup</a></h3>

<h2><a name="block-switch">Switch</a></h2>
<pre class="exl">switch (&lt;expression&gt;, (SELF|PARENT), &lt;ID&gt;, &lt;expression&gt;) {
	(&lt;range&gt;: &lt;return_value&gt;;)*
	&lt;return_value&gt;;
}</pre>
<p><code>&lt;range&gt;</code> can either number or two numbers seperated by
two dots.</p>
<p><code>&lt;return_value&gt;</code> can be either a literal <code>return</code>,
a literal <code>return</code> followed by an expression, an <code>ID</code> that
is the name of another switchblock or spriteblock or a string. If the
<code>return_value</code> is just a literal <code>return</code>, then the value
of the computation is returned. If it's a string or a <code>return</code>
followed by an expression then that value is returned. Otherwise it's the ID
of a spriteblock or switch and that block will be evaluated.

<h2><a name="block-randomswitch">Random switch</a></h2>
<p>While a <a href="#block-switch">switch-block</a> allows making a predictable
desicion, a random_switch allows a randomized choice between several options.</p>
<pre class="exl">random_switch (&lt;feature&gt;, &lt;type&gt;, &lt;ID&gt;[, &lt;triggers&gt;]) {
    (&lt;independent&gt;: &lt;other_random&gt;;)*
    (&lt;dependent&gt;: &lt;other_random&gt;;)*
	(&lt;probability&gt;: &lt;return_value&gt;;)+
}</pre>
<p>The first parameter <code>&lt;feature&gt;</code> specifies the feature to use.
<code>&lt;type&gt;</code>, the second parameter, is used to define what random data
is used. The supported combinations are listed in the following table. The amount
of random data is given in the third column. The maximum number of possible
combinations is equal to 2^x, with x being the number of random bits. The last
column specifies the object of which the random data is used.</p>

<table class="t">
<tr><th>Feature</th><th>Type</th><th># of random bits</th><th>Random data used</th></tr>
<tr><td>Vehicles</td><td>SELF</td><td>8</td><td>Vehicle itself</td></tr>
<tr><td>Vehicles</td><td>PARENT</td><td>8</td><td>Leading engine</td></tr>
<tr><td>Vehicles</td><td>BACKWARD_SELF(x)</td><td>8</td><td>Count x vehicles backward (away from the engine), starting at the vehicle itself (a)</td></tr>
<tr><td>Vehicles</td><td>FORWARD_SELF(x)</td><td>8</td><td>Count x vehicles forward (towards the engine), starting at the vehicle itself (a)</td></tr>
<tr><td>Vehicles</td><td>BACKWARD_ENGINE(x)</td><td>8</td><td>Count x vehicles backward, starting at the leading engine (a)</td></tr>
<tr><td>Vehicles</td><td>BACKWARD_SAMEID(x)</td><td>8</td><td>Count x vehicles backward, starting at the first vehicle in the chain with the same ID (a)</td></tr>
<tr><td>Stations / airport tiles</td><td>SELF</td><td>16</td><td>Station</td></tr>
<tr><td>Stations / airport tiles</td><td>TILE</td><td>4</td><td>Specific station tile</td></tr>
<tr><td>Canals</td><td>SELF</td><td>8</td><td>Canal tile</td></tr>
<tr><td>Houses</td><td>SELF</td><td>8</td><td>House tile (b)</td></tr>
<tr><td>Industry tiles</td><td>SELF</td><td>8</td><td>Industry tile</td></tr>
<tr><td>Industry tiles</td><td>PARENT</td><td>16</td><td>Industry as a whole</td></tr>
<tr><td>Industries</td><td>SELF</td><td>16</td><td>Industry (same as above)</td></tr>
<tr><td>Objects</td><td>SELF</td><td>8</td><td>Object tile (different per tile)</td></tr>
<tr><td>Rail types</td><td>SELF</td><td>2</td><td>Rail tile (pseudo-random, based on location)</td></tr>
</table>
<p>(a) x can be any expression. It can even contain variables, in that case
the variables of the vehicle itself are used.</p>
<p>(b) The random bits are initially the same for all tiles of a multi-tile house.</p>
<p>The third parameter <code>&lt;ID&gt;</code> can be used to refer to this
block from other (random-)switch-blocks. The last parameter
<code>&lt;triggers&gt;</code> is optional and allows re-randomizing when
certain conditions occur. The events and accompanying trigger names are
given in the following tables. To re-randomize graphics when any of a set of
events occurs, use <code>TRIGGER_A | TRIGGER_B | ... | TRIGGER_Z</code>
To re-randomize only when <em>all</em> of the events have occured, add <code>TRIGGER_ALL</code> to the list of used triggers, e.g. use
<code>TRIGGER_ALL | TRIGGER_A | ...</code></p>

<table class="t">
<caption>Vehicle triggers</caption>
<tr><th>Trigger</th><th>Event</th></tr>
<tr><td>TRIGGER_VEHICLE_NEW_LOAD</td><td>Vehicle gets new load of cargo (only after it was empty)</td></tr>
<tr><td>TRIGGER_VEHICLE_SERVICE</td><td>Vehicle enters a depot and is serviced</td></tr>
<tr><td>TRIGGER_VEHICLE_UNLOAD_ALL</td><td>The consist has unloaded all cargo (use with type 'SELF')</td></tr>
<tr><td>TRIGGER_VEHICLE_ANY_LOAD</td><td>Any vehicle of the consist receives cargo (use with type 'SELF')</td></tr>
<tr><td>TRIGGER_VEHICLE_32_CALLBACK</td><td>32-day callback returned 1</td></tr>
</table>
<p>To re-randomize when the consist has been emptied and then receives new cargo, use
<code>TRIGGER_VEHICLE_UNLOAD_ALL | TRIGGER_VEHICLE_ANY_LOAD | TRIGGER_ALL</code></p>

<table class="t">
<caption>Station triggers</caption>
<tr><th>Trigger</th><th>Event</th></tr>
<tr><td>TRIGGER_STATION_NEW_CARGO</td><td>New cargo waiting</td></tr>
<tr><td>TRIGGER_STATION_NO_MORE_CARGO</td><td>No more cargo waiting</td></tr>
<tr><td>TRIGGER_STATION_TRAIN_ARRIVES</td><td>Train arrives (starts loading/unloading)</td></tr>
<tr><td>TRIGGER_STATION_TRAIN_LEAVES</td><td>Train leaves (done loading/unloading)</td></tr>
<tr><td>TRIGGER_STATION_TRAIN_LOADS_UNLOADS</td><td>Train loads/unloads cargo</td></tr>
<tr><td>TRIGGER_STATION_TRAIN_RESERVES</td><td>Train reserves platform using PBS</td></tr>
</table>
<p>The last four triggers in the table only trigger on the platform on which they occur.</p>

<table class="t">
<caption>House triggers</caption>
<tr><th>Trigger</th><th>Event</th></tr>
<tr><td>TRIGGER_HOUSE_TILELOOP</td><td>The house tile is processed in the periodic tile-processing loop</td></tr>
<tr><td>TRIGGER_HOUSE_TOP_TILELOOP</td><td>The top tile of the house is processed in the periodic tile-processing loop</td></tr>
</table>
<p>Using <code>TRIGGER_HOUSE_TOP_TILELOOP</code>, it is possible to re-randomize
the whole building as one unit. All tiles of a multi-tile house will get the same
new random data.</p>

<table class="t">
<caption>Industry tile triggers</caption>
<tr><th>Trigger</th><th>Event</th></tr>
<tr><td>TRIGGER_INDUSTRYTILE_TILELOOP</td><td>The industry tile is processed in the periodic tile-processing loop </td></tr>
<tr><td>TRIGGER_INDUSTRYTILE_256_TICKS</td><td>Triggers simultaneously for all tiles of the industry every 256 ticks.
If the industry is a primary one, output cargo is generated at the same time.</td></tr>
<tr><td>TRIGGER_INDUSTRYTILE_CARGO_DELIVERY</td><td>Cargo is delivered to the industry. If the industry is a processing one, output cargo is generated at the same time.</td></tr>
</table>

<p><code>&lt;independent&gt;: &lt;other_random&gt;;</code> makes sure that this
random_switch block and <code>&lt;other_random&gt;</code> use different
(non-intersecting) random data. This allows making multiple randomized
desicions that are independent of eachother.</p>
<p><code>&lt;dependent&gt;: &lt;other_random&gt;;</code>, on the other hand,
lets this random_switch block and <code>&lt;other_random&gt;</code> use the same
random data. To make this possible, it should not require more random data
(i.e. have a higher sum of probabilities) than the block it is dependent on.</p>
<p>Both of these options require enough random data to be available. Also, the
combination must make sense. For example, if A is dependent on B and B is
dependent on C, then A cannot be independent of C.</p>
<p>Following this, there is a list of options, one of which will be chosen
randomly. The syntax is <code>&lt;probability&gt;: &lt;return_value&gt;;</code>.
The relative probability that this option will be chosen is given by
<code>&lt;probability&gt;</code>. The chance is equal to the probability divided
by the sum of all probabilities. If this sum is not equal to a power of two (2,
4, 8, 16, ...), then rounding is done and the probabilities may be inexact. For
information about <code>&lt;return_value&gt;</code>, see the
<a href="#block-switch">switch-block</a>. Let's conclude with an example:
<pre class="code">random_switch (FEAT_TRAINS, SELF, random_42, TRIGGER_VEHICLE_UNLOAD_ALL | TRIGGER_VEHICLE_ANY_LOAD | TRIGGER_ALL) {
    /* re-randomize when vehicle has been emptied and then received new cargo */
    independent: random_43; // desicion should be independent from random_43, which is defined elsewhere
    6: group_open;          // 6/11 chance to display open wagon
    3: group_closed;        // 3/11 chance to display closed wagon (with cover)
    2: group_halfopen;      // 2/11 chance to display a half-covered wagon
}</pre>

<h2><a name="block-template">Template</a></h2>

<h2><a name="block-cargotable">Cargotable</a></h2>
<pre class="exl">cargotable {
	ID [, ID]*
}</pre>
<p>The cargotable is a list of 4-byte long IDs. For example:</p>
<pre class="code">cargotable {
	PASS, MAIL, GOOD, COAL
}</pre>

<h2><a name="block-if">If/else</a></h2>
<pre class="exl">
if (expression) {
	block;
} else {
	block;
}
</pre>
<p>For example:</p>
<pre class="code">
if (param[1] == 1) {
	param[2] = 3
} else {
	param[2] = 5
}
</pre>

<h2><a name="block-while">While</a></h2>

<h2><a name="block-error">Error</a></h2>
The general form of an error statement is
<pre="exl">
error(level, message[, extra_text[, parameter1[, parameter2]]])
</pre>
where level is the severity of the message and one of <code>NOTICE, WARNING, ERROR, FATAL</code>. The message can be either a customly
defined string which can contain up to two parameters or it can be one of the pre-defined strings which already have translations. The first
{STRING}-code will always be replaced by the NewGRF name. The second {STRING}-code will be replaced by the value of 'extra_text'.
<table class="t">
<r><th>name <th>actual text<th>Contents of extra_text
<tr><td>REQUIRES_TTDPATCH <td>"{STRING} requires at least TTDPatch version {STRING}"<td>version string
<tr><td>REQUIRES_DOS_WINDOWS <td>"{STRING} is for the {STRING} version of TTD."<td>[DOS | Windows]
Palette type
<tr><td>USED_WITH <td>"{STRING} is designed to be used with {STRING}"<td>switchname + value, e.g. "multihead 0". This is designed to be used
for incompatible settings that you can check via ttdpatch_flags.
<tr><td>INVALID_PARAMETER <td>"Invalid parameter for {STRING}: parameter {STRING} ({PARAM})"<td>extra_text should be the parameter number written
out as string. {PARAM} is replaced by parameter1.
filled in.
<tr><td>MUST_LOAD_BEFORE <td>"{STRING} must be loaded before {STRING}."<td>NewGRF name
<tr><td>MUST_LOAD_AFTER <td>"{STRING} must be loaded after {STRING}."<td>NewGRF name
<tr><td>REQUIRES_OPENTTD <td>"{STRING} requires OpenTTD version {STRING} or better."<td>version string
<tr><td>./.<td>(user-defined string)<td>The message-string can use the code {STRING} up to 2 times, the first usage will be replaced by the
NewGRF name and the second usage by 'extra_text'. After 2 {STRING}-codes you can include up to 2 {PARAM}-codes that will be replaced
by the contents of parameter1 and parameter2.
</table>

For example:
<pre class="code">
error(NOTICE, USED_WITH, STR_REGRESSION_CARE);
error(FATAL, STR_REGRESSION_ERROR, STR_ANSWER, 14, param[1] + 12 * param[2]);
</pre>
<h2><a name="block-deactivate">Deactivate</a></h2>

<h2><a name="block-replacement">Sprite replacement</a></h2>
<p>This section covers the three available methods to replace sprites.
Which one to use depends on the type of sprites you want to replace. The following
sections will outline the detailed functionality of these blocks and when to use them.</p>

<h3><a name="block-replacement-replace">Replace TTD sprites</a></h3>
<p>Using a <code>replace</code> block, it is possible to replace TTD's built-in sprites.
The syntax is as follows:</p>
<pre class="exl">replace(&lt;sprite-id&gt;, &lt;image-file&gt;) {
	&lt;real-sprites&gt;...
}</pre>
<p>The first parameter <code>&lt;sprite-id&gt;</code> should be a compile-time constant
that indicates the sprite number of the first sprite to replace. Sprite numbers are
equal to the sprite numbers in the base graphics file. The
<a href="http://mz.openttdcoop.org/opengfx/authors/script.php?feature=spritesbyfile&amp;q=ogfx1_base">
OpenGFX author overview</a> can be used as a reference to look up these sprite numbers.
The second parameter <code>&lt;image-file&gt;</code> specifies the image file that contains
the new sprites. A series of real sprites has to be specified between the curly braces
(<code>{</code> and <code>}</code>). The first sprite in this list replaces sprite with id
<code>sprite-id</code>, the second replaces <code>sprite-id + 1</code> and so on.
Sprite templates can be used as well. For example:</p>
<pre class="code">
// Rail overlays for crossings
replace (1005, "src/gfx/rails_overlays.png") {
		[ 20,198, 40,21, -20,  5]
		[ 71,198, 40,21, -20,  5]
		[117,198, 40, 7, -20,  5]
		[165,198, 40, 7, -20, 21]
		[216,198, 12,19,  10,  5]
		[248,198, 12,19, -24, 11]
}
</pre>

<h3><a name="block-replacement-replacenew">Replace new sprites</a></h3>
<p>Over time, several features have been added to TTDPatch and OpenTTD that require new
sprites. As these sprites are not present in the original base graphics, they cannot
be replaced using a normal <code>replace</code> block. Instead, a <code>replacenew</code>
block has to be used. The semantics are like this:</p>
<pre class="exl">replacenew(&lt;type&gt;, &lt;image-file&gt;[, &lt;offset&gt;]) {
	&lt;real-sprites&gt;...
}</pre>
<p>The <code>&lt;type&gt;</code> parameter indicates the type of sprites that will
be replaced. It should be an identifier from the first column of the following table.</p>

<!-- This table could use some information regarding versioning, descriptions
 and references to which sprites are actually needed. However this is a lot
 of work (even TTDP wiki doesn't list all info) and this is not really a
 high priority job -->
<table class="t">
	<tr><th>Type</th><th>Number of sprites</th></tr>
	<tr><td>PRE_SIGNAL</td><td>48</td></tr>
	<tr><td>PRE_SIGNAL_SEMAPHORE</td><td>112</td></tr>
	<tr><td>PRE_SIGNAL_SEMAPHORE_PBS</td><td>240</td></tr>
	<tr><td>CATERNARY</td><td>48</td></tr>
	<tr><td>FOUNDATIONS_SLOPES</td><td>74</td></tr>
	<tr><td>FOUNDATIONS_SLOPES_HALFTILES</td><td>90</td></tr>
	<tr><td>TTDP_GUI_25</td><td>73</td></tr>
	<tr><td>TTDP_GUI</td><td>93</td></tr>
	<tr><td>CANALS</td><td>65</td></tr>
	<tr><td>ONE_WAY_ROAD</td><td>6</td></tr>
	<tr><td>COLORMAP_2CC</td><td>256</td></tr>
	<tr><td>TRAMWAY</td><td>113</td></tr>
	<tr><td>SNOWY_TEMPERATE_TREES</td><td>133</td></tr>
	<tr><td>COAST_TILES</td><td>16</td></tr>
	<tr><td>COAST_TILES_BASEGFX</td><td>10</td></tr>
	<tr><td>COAST_TILES_DIAGONAL</td><td>18</td></tr>
	<tr><td>NEW_SIGNALS</td><td>any (a)</td></tr>
	<tr><td>SLOPED_RAILS</td><td>12</td></tr>
	<tr><td>AIRPORTS</td><td>15</td></tr>
	<tr><td>ROAD_STOPS</td><td>8</td></tr>
	<tr><td>AQUEDUCTS</td><td>8</td></tr>
	<tr><td>AUTORAIL</td><td>55</td></tr>
	<tr><td>FLAGS</td><td>36 (b)</td></tr>
	<tr><td>OTTD_GUI</td><td>154 (b)</td></tr>
</table>

<p>(a) Any number of sprites is allowed here, however both OpenTTD and
NML don't (yet) support the other features required to use these sprites.</p>

<p>(b) Any number of sprites can be specified up to the stated maximum.
Furthermore the <code>offset</code> variable can be used, see below for
more info.</p>

<p>The amount of sprites has to be equal to the number list has to be
equal to the number given in the table, except in the cases of (a) and (b).
Having less sprites results in an error. Having more sprites is allowed
to provide future compatibility, but a warning will be issued.</p>

<p>Parameter two <code>&lt;image-file&gt;</code> is a literal (quoted) string
that specifies the file where the sprites are located.</p>
<p>Parameter <code>&lt;offset&gt;</code> is optional and has a default value of 0.
Values greater than zero are only allowed in the case of the sprite types marked
with (b). Setting this value sets an offset into the block of sprites, so only a
subset of the sprites (starting at <code>offset</code>) will be replaced.</p>

<h3><a name="block-replacement-fontglpyh">Add font glpyhs</a></h3>
<p>A <code>font-glpyh</code> block makes it possible to provide sprites
for glyphs that don't have sprites in normal TTD. The syntax is as follows:</p>

<pre class="exl">font_glpyh (&lt;font-size&gt;, &lt;base-char&gt;, &lt;image-file&gt;) {
	&lt;real-sprites&gt;...
}</pre>

<p>The first parameter (<code>&lt;font-size&gt;</code>) should be an identifier
of the font size to use. Valid values are <code>SMALL</code>, <code>NORMAL</code>
and <code>LARGE</code>.</p>
<p>The second parameter (<code>&lt;base-char&gt;</code>) is the number
corresponding to the first character to provide a sprite for. Valid values are
all unicode code points in the Basic Multilingual Plane (0-0xFFFF)</p>
<p>Parameter three <code>&lt;image-file&gt;</code> is a literal (quoted) string
that specifies the file where the sprites are located.</p>
<p><code>&lt;real-sprites&gt;</code> should be a list of real sprites. The first
real sprite will be used for the character with code <code>base-char;</code>, the
second for <code>base-char + 1</code> and so on. These sprites should only use
color palette indices 0 (transparant), 1 (foreground) and 2 (shadow). If the
shadow color is used, sprite compression flag 'TILE' must NOT be set.</p>

<h2><a name="block-town_names">Town names</a></h2>
<p>To define randomly generated town names, the <tt>town_names</tt> block should
be used. Such blocks can be used in two ways, as generator of (partial) town
names for another block, or as top-level town names block, the starting point of the
grf file. You must have at least one starting point, but you can have more
than one.</p>
<p>The general syntax of a town names block is:</p>
<pre class="exl">town_names[(&lt;name&gt;)] {
	[styles : &lt;string&gt;]
	&lt;part&gt; &lt;part&gt; ....
}</pre>
<p>The optional <code>&lt;name&gt;</code> defines the name of the block. Such a
name is used to refer to this block from another town names block.
For top-level town names blocks, it is often left out. Note that in that case,
you must also leave out the parentheses.</p>
<p>If specified, it can be either a number (from 0 up to 127), or an
identifier. Such a name is used to refer to this block from another town names
block. Note that if you leave out the name, you should also leave out the
parentheses.</p>
<p>The optional <code>&lt;string&gt;</code> defines how the town names are
called in the menu. It may only be defined in a top-names block. To make the
name available in all languages, it is probably a good idea to at least define
a menu name if the generic language.</p>

<h3><a name="block-town_names-parts">Town names parts</a></h3>
<p>A <code>town_names</code> block has one or more <code>&lt;part&gt;</code>s.
Each part defines a piece of a town name. All pieces together form the name
generated by the block.</p>
<p>An example of a part is:</p>
<pre class="code">{
	text("name1", 1),
	text("name2", 2),
	town_names(othernames, 3)
}</pre>
<p>The simplest form is just a list of <code>text(...)</code>entries.
Each entry contains a possible value of piece, and a probability of picking
that name. The <code>town_names(&lt;name&gt;, &lt;probability&gt;)</code>calls
a previous <code>town_names</code> block (called 'othernames' in the example),
and returns the value generated there.
A part should have at least one and at most 255 entries.</p>
<p>The numbers are the probabilities. In the example, the sum of all values is
6, which means that <code>name1</code> is picked with 1/6 chance,
<code>name2</code> has a 2/6 chance, and a name generated from the previous
<code>town_names</code> block has a 3/6 chance.</p>


<h2><a name="block-assignment">Parameter assignment</a></h2>
<pre class="exl">param[&lt;expression&gt;] = &lt;expression&gt;;</pre>
<p>Set a parameter to the given expression. Neither of the two expessions has
to be constant, the following is perfectly valid:</p>
<pre class="code">param[param[2] + 1] = param[3] * param[4];</pre>

<h2><a name="block-sounds">Sound support</a></h2>
<p>Sounds are supported by means of the <code>sounds</code> block.
An example of a sounds block that defines two new sounds is:</p>
<pre class="code">sounds {
        load_soundfile("whistle.wav");
        import_sound(0x87654321, 3);
}</pre>
<p>The block starts with the keyword <code>sounds</code>, followed by one
or more sound definitions. A sound definition either loads a sound file (like
the <code>load_soundfile("whistle.wav");</code> which includes the
<i>whistle.wav</i> file), or it refers to a sound from another NewGRF file
(like the <code>import_sound(0x87654321, 3);</code> which imports the fourth
sound from the NewGRF file with ID <code>0x87654321</code>). Importing sounds
does not make copies of the data, thus saving memory space.</p>
<p>You can have at most one <code>sounds</code> block in a NewGRF file. When
using a sound from a sound block, the first sound gets number <code>73</code>,
the second sound gets number <code>74</code>, and so on. Note that this is
different from the numbering that you use when importing a sound from
another NewGRF, as counting starts at <code>0</code> in that case.</p>
<p>All loaded sound files must be
8-bit mono sound files in WAV format, PCM encoding. There are two allowed
frequencies: 11025 Hz and 22050 Hz. Due to some limitations of the NewGRF format,
the file size cannot exceed 64KB.</p>

<h1><a name="units">Units</a></h1>

<h1><a name="expressions">Expressions</a></h1>

<h2><a name="elementary-values">elementary values</a></h2>
Elementary values in expressions are
<table class="t">
<tr><th>Element<th>Syntax (Python RE)<td>Description
<tr><td>Decimal number<td>[0-9]+<td>one or more digits
<tr><td>Hexadecimal number<td>0x[0-9A-Fa-f]+<td>"0x" followed by one or more hexadecimal digits
<tr><td>Floating point number<td>[0-9]+\.[0-9]+<td>a decimal number, a dot, and another decimal number
<tr><td>Identifier<td>[a-zA-Z_][a-zA-Z0-9_]*<td>a letter or underscore, optionally followed by more letters, digits, or underscore characters
<tr><td>Unit<td>nfo|mph|km/h|m/s|hp|ton<td>One of the strings "nfo", "mph", "km/h", "m/s", "hp", or "ton" (without quotes)
<tr><td>String<td>"([^"\\]|\\.)*"<td>A double quote character, followed by zero or more characters, ending with another double quote character. A character in-between is any single character except a double quote or a back-slash ("\"). It can also be "\\", "\n", "\t", or "\[0-9A-Fa-f][0-9A-Fa-f]" (a back-slash followed by exactly two hexadecimal digits).
</table>

<h2><a name="builtin-functions">Builtin functions</a></h2>
Available builtin functions are
<table class="t">
<tr><th>Function<th>Description
<tr><td>min(<i>v1</i>, <i>v2</i>)<td>Return the smallest value
<tr><td>max(<i>v1</i>, <i>v2</i>)<td>Return the biggest value
<tr><td>date(<i>year</i>, <i>month</i>, <i>day</i>)<td>If all values are constants, returns the number of days since year 0. If the year is a variable, the month and day should be 1.
<tr><td>day_of_year(<i>month</i>, <i>day</i>)<td>Return the day of the year
since January 1st. Both values must be compile-time constants.
<tr><td>bitmask(<i>bitpos1</i>, ...)<td>Compose an integer by switching the bits at the given positions on.
<tr><td>STORE_TEMP(<i>value</v1>, <i>address</i>)<td>Store value in temporary storage
<tr><td>STORE_PERM(<i>value</v1>, <i>address</i>)<td>Store value in permanent storage
<tr><td>LOAD_TEMP(<i>address</i>)<td>Get value from temporary storage
<tr><td>LOAD_PERM(<i>address</i>)<td>Get value from permanent storage
<tr><td>hasbit(<i>v1</v1>, <i>v2</i>)<td>Test whether a bit in a value is on
<tr><td>version_openttd(<i>major</i>, <i>minor</i>, <i>revision</i>[, <i>build</i>])<td>Return the constant representing an Openttd version
</table>


<h1><a name="language-files">Language files</a></h1>
Language files are usually found in the <code>lang</code> sub-folder of the 
project, but the place NML looks for the language files can be changed via command 
line parameter to any directory desired:
<pre class="code">
nml2nfo -l path/to/lang-dir path/to/nml-source-file.nml
nml2nfo --lang-dir=path/to/lang-dir path/to/nml-source-file.nml
</pre>
Language files MUST have the extension <code>.lng</code><br>
The language files themselves follow a certain structure:
<pre class="exl">
lang: &lt;number&gt;
&lt;string-name&gt;                                                   :&lt;text&gt;
&lt;string-name&gt;                                                   :&lt;text&gt;
...
</pre>
where the first line must give the language code for the language this file
describes (see below). The following lines each describe a string. The translated
string follows immediately the colon. A NewGRF project must contain a language file
for the default fallback language 7F.

Example for a valid language file:
<pre class="code">
lang: 7F
STR_GRF_NAME                                                    :Swedish Rails {VERSION}
STR_GRF_DESCRIPTION                                             :Swedish rails are a graphical extension for rails.
</pre>

Strings may contain a number of special string codes which control how the string is being printed or which insert 
values into the string. Custom replacements can be stored in the file <code>custom_tags.txt</code> (for example a
newgrf version which is written by your build script).

Valid language IDs are
<table class="t">
<tr><th>ID <th>language
<tr><td>7F<td>default fallback
<tr><td>00<td>American
<tr><td>01<td>English
<tr><td>02<td>German
<tr><td>03<td>French
<tr><td>04<td>Spanish
<tr><td>05<td>Esperanto
<tr><td>06<td>Ido
<tr><td>07<td>Russian
<tr><td>08<td>Irish
<tr><td>09<td>Maltese
<tr><td>0A<td>Tamil
<tr><td>0B<td>Chuvash
<tr><td>0C<td>Chinese (Traditional)
<tr><td>0D<td>Serbian
<tr><td>0E<td>Norwegian (Nynorsk)
<tr><td>0F<td>Welsh
<tr><td>10<td>Belarusian
<tr><td>14<td>Arabic (Egypt)
<tr><td>15<td>Czech
<tr><td>16<td>Slovak
<tr><td>18<td>Bulgarian
<tr><td>1B<td>Afrikaans
<tr><td>1E<td>Greek
<tr><td>1F<td>Dutch
<tr><td>21<td>Basque
<tr><td>22<td>Catalan
<tr><td>23<td>Luxembourgish
<tr><td>24<td>Hungarian
<tr><td>26<td>Macedonian
<tr><td>27<td>Italian
<tr><td>28<td>Romanian
<tr><td>29<td>Icelandic
<tr><td>2A<td>Latvian
<tr><td>2B<td>Lithuanian
<tr><td>2C<td>Slovenian
<tr><td>2D<td>Danish
<tr><td>2E<td>Swedish
<tr><td>2F<td>Norwegian (Bokmal)
<tr><td>30<td>Polish
<tr><td>31<td>Galician
<tr><td>32<td>Frisian
<tr><td>33<td>Ukrainian
<tr><td>34<td>Estonian
<tr><td>35<td>Finnish
<tr><td>36<td>Portuguese
<tr><td>37<td>Brazilian Portuguese
<tr><td>38<td>Croatian
<tr><td>39<td>Japanese
<tr><td>3A<td>Korean
<tr><td>3C<td>Malay
<tr><td>3E<td>Turkish
<tr><td>42<td>Thai
<tr><td>54<td>Vietnamese
<tr><td>56<td>Chinese (Simplified)
<tr><td>5A<td>Indonesian
<tr><td>5C<td>Urdu
<tr><td>61<td>Hebrew
<tr><td>62<td>Persian
</table>

<h1><a name="properties">List of properties</a></h1>
<h2><a name="property-trains">Trains</a></h2>
<table class="t">
<tr><th> property</th><th>value range</th><th>comment</th></tr>
<!-- properties common to all vehicle types -->
<tr><td> name</td><td>                         (string)</td><td>for example <code>string(STR_NAME_HEREFORD_TRAM)</code></td></tr>
<tr><td> climates_available</td><td>           BitMask(CLIMATE_XXX, CLIMATE_YYY, ...)</td><td>XXX = [TEMPERATE | ARCTIC | TROPIC | TOYLAND], alternatively CLIMATE_NONE or CLIMATE_ALL</td></tr>
<tr><td> model_life</td><td>                   0 ... 255 (years)</td><td></td></tr>
<tr><td> vehicle_life</td><td>                 0 ... 255 (years)</td><td></td></tr>
<tr><td> introduction_date</td><td>            date(yyyy,mm,dd)</td><td></td></tr>
<tr><td> reliability_decay</td><td>            0 ... 255</td><td>n/a</td></tr>
<tr><td> loading_speed <td>                    0 ... 255 (cargo units) <td> units loaded per tick
<tr><td> refittable_cargo_classes</td><td>     bit set of <a href="#property-cargos">cargo classes</a></td><td></td></tr>
<tr><td> non_refittable_cargo_classes</td><td> bit set of <a href="#property-cargos">cargo classes</a></td><td></td></tr>
<tr><td> running_cost_factor</td><td>0 ... 255</td><td>multiplicator to the base cost</td></tr>
<tr><td> retire_early<td> (years)<td>reliability of new vehicles starts to decrease <i>model life</i>-8-<i>retire_early</i> after vehicle introduction. Value of
<i>retire_early</i> may be negative.
<tr><td> cost_factor</td><td> 0 ... 255</td><td>purchase cost; mutliplicator to the base cost</td></tr>
<tr><td> running_cost_factor<td> 0 ... 255<td> multiplicator to the base running costs
<tr><td> refittable_cargo_types<td> bit mask of entries into the cargo translation table<td>example: <code>bitmask(PASS, MAIL, GOOD)</code>

<!-- properties common to all vehicle types but with different value ranges or meaning -->
<tr><td> sprite_id</td><td>SPRITE_ID_NEW_TRAIN</td><td>define base set spriteID to replace or this constant</td></tr>
<tr><td> speed<td> 0 ... 65000 (speed units)<td>Max speed for engines, speed limit for wagons
<tr><td> misc_flags</td><td>                   TRAIN_FLAG_XXX</td><td>XXX=[TILT | 2CC | MU]</td></tr>
<tr><td> refit_cost<td> <td> in 50% units of the purchase price cost base
<tr><td> callback_flags<td> CBF_XXX<td>XXX = [WAGON_POWER | WAGON_LENGTH | REFITTED_CAPACITY | LOAD_AMOUNT | REFITTED_CAPACITY | CARGO_SUFFIX | COLOR_MAPPING | SOUND_EFFECT]

<!-- properties not present for all vehicle types -->
<tr><td> track_type<td> TRACK_TYPE_XXX<td>XXX=[RAIL | MONORAIL | MAGLEV]
<tr><td> ai_special_flag<td> [AI_FLAG_PASSENGER | AI_FLAG_CARGO]<td> For TTDPatch only: set to AI_FLAG_PASSENGER to tell the AI that it's an engine for passenger service
<tr><td> power<td> 0 ... 65000 hp (power units) <td>
<tr><td> running_cost_base</td><td>RUNNING_COST_XXX</td><td>XXX = [STEAM | DIESEL | ELECTRIC | ROADVEH | NONE]</td></tr>
<tr><td> dual_headed<td> [0 | 1]<td>1 = dual_headed, otherwise normal engine
<tr><td> cargo_capacity<td> (cargo units)<td>
<tr><td> cargo_type<td> (cargo label)<td> use one from your cargo translation table
<tr><td> weight<td> 0 .. 20000 t (mass units)<td>
<tr><td> ai_engine_rank<td> 0 ... 255<td>higher values make the engine for the TTDPatch AI more attractive
<tr><td> engine_class<td> ENGINE_CLASS_XXX<td>XXX=[STEAM | DIESEL | ELECTRIC | MONORAIL | MAGLEV]
<tr><td> extra_power_per_wagon<td> (power units) <td>
<tr><td> tractive_effort_coefficient<td> 0 ... 1<td>
<tr><td> air_drag_coefficient</td><td>   0 ... 1</td><td></td></tr>
<tr><td> shorten_vehicle<td> SHORTEN_TO_XXX<td>XXX=[8_8 | 7_8 | ... | 1_8]
<tr><td> visual_effect<td> VISUAL_EFFECT_XXX<td>XXX=[DEFAULT | STEAM | DIESEL | ELECTRIC | DISABLE]
<tr><td> extra_weight_per_wagon<td> (mass units)<td>
<tr><td> bitmask_vehicle_info<td> 8-bit bitmask<td>Used for obtaining bitmask_consist_info
<tr><td> <td> <td>
</table>
<h2><a name="property-roadvehs">Road vehicles</a></h2>
<table class="t">
<tr><th> property</th><th>value range</th><th>comment</th></tr>
<!-- properties common to all vehicle types -->
<tr><td> name</td><td>                         (string)</td><td>for example <code>string(STR_NAME_HEREFORD_TRAM)</code></td></tr>
<tr><td> climates_available</td><td>           BitMask(CLIMATE_XXX, CLIMATE_YYY, ...)</td><td>XXX = [TEMPERATE | ARCTIC | TROPIC | TOYLAND], alternatively CLIMATE_NONE or CLIMATE_ALL</td></tr>
<tr><td> model_life</td><td>                   0 ... 255 (years)</td><td></td></tr>
<tr><td> vehicle_life</td><td>                 0 ... 255 (years)</td><td></td></tr>
<tr><td> introduction_date</td><td>            date(yyyy,mm,dd)</td><td></td></tr>
<tr><td> reliability_decay</td><td>            0 ... 255</td><td>n/a</td></tr>
<tr><td> loading_speed <td>                    0 ... 255 (cargo units) <td> units loaded per tick
<tr><td> refittable_cargo_classes</td><td>     bit set of <a href="#property-cargos">cargo classes</a></td><td></td></tr>
<tr><td> non_refittable_cargo_classes</td><td> bit set of <a href="#property-cargos">cargo classes</a></td><td></td></tr>
<tr><td> retire_early<td> (years)<td>reliability of new vehicles starts to decrease <i>model life</i>-8-<i>retire_early</i> after vehicle introduction. Value of
<i>retire_early</i> may be negative.
<tr><td> cost_factor</td><td> 0 ... 255</td><td>purchase cost; mutliplicator to the base cost</td></tr>
<tr><td> running_cost_factor<td> 0 ... 255<td> multiplicator to the base running costs
<tr><td> refittable_cargo_types<td> bit mask of entries into the cargo translation table<td>example: <code>bitmask(PASS, MAIL, GOOD)</code>

<!-- properties common to all vehicle types but with different value ranges or meaning -->
<tr><td> sprite_id</td><td>                    SPRITE_ID_NEW_ROADVEH</td><td>define base set spriteID to replace or this constant</td></tr>
<tr><td> speed</td><td>                        0 ... 65000km/h (speed units)</td><td></td></tr>
<tr><td> misc_flags</td><td>                   ROADVEH_FLAG_XXX</td><td>road vehicle flags</td></tr>
<tr><td> refit_costs<td> <td> in 25% units of the purchase price cost base
<tr><td> callback_flags<td> CBF_XXX<td>XXX = [LOAD_AMOUNT | REFITTED_CAPACITY | CARGO_SUFFIX | COLOR_MAPPING | SOUND_EFFECT]

<!-- properties not present for all vehicle types -->
<tr><td> running_cost_base</td><td>            RUNNING_COST_XXX</td><td>XXX = [STEAM | DIESEL | ELECTRIC | ROADVEH | NONE]</td></tr>
<tr><td> power</td><td>                        0 ... 65000kN (power units)</td><td></td></tr>
<tr><td> weight</td><td>                       0 ... 65000t (mass units)</td><td></td></tr>
<tr><td> tractive_effort_coefficient</td><td>  0 ... 1</td><td></td></tr>
<tr><td> air_drag_coefficient</td><td>         0 ... 1</td><td></td></tr>
<tr><td> cargo_capacity</td><td>               0 ... 65000</td><td></td></tr>
<tr><td> cargo_type<td> (cargo label)<td> use one from your cargo translation table

</table>
<h2><a name="property-ships">Ships</a></h2>
<table class="t">
<tr><th> property</th><th>value range</th><th>comment</th></tr>
<!-- properties common to all vehicle types -->
<tr><td> name</td><td>                         (string)</td><td>for example <code>string(STR_NAME_HEREFORD_TRAM)</code></td></tr>
<tr><td> climates_available</td><td>           BitMask(CLIMATE_XXX, CLIMATE_YYY, ...)</td><td>XXX = [TEMPERATE | ARCTIC | TROPIC | TOYLAND], alternatively CLIMATE_NONE or CLIMATE_ALL</td></tr>
<tr><td> model_life</td><td>                   0 ... 255 (years)</td><td></td></tr>
<tr><td> vehicle_life</td><td>                 0 ... 255 (years)</td><td></td></tr>
<tr><td> introduction_date</td><td>            date(yyyy,mm,dd)</td><td></td></tr>
<tr><td> reliability_decay</td><td>            0 ... 255</td><td>n/a</td></tr>
<tr><td> loading_speed <td>                    0 ... 255 (cargo units) <td> units loaded per tick
<tr><td> refittable_cargo_classes</td><td>     bit set of <a href="#property-cargos">cargo classes</a></td><td></td></tr>
<tr><td> non_refittable_cargo_classes</td><td> bit set of <a href="#property-cargos">cargo classes</a></td><td></td></tr>
<tr><td> retire_early<td> (years)<td>reliability of new vehicles starts to decrease <i>model life</i>-8-<i>retire_early</i> after vehicle introduction. Value of
<i>retire_early</i> may be negative.
<tr><td> cost_factor</td><td> 0 ... 255</td><td>purchase cost; mutliplicator to the base cost</td></tr>
<tr><td> running_cost_factor<td> 0 ... 255<td> multiplicator to the base running costs
<tr><td> refittable_cargo_types<td> bit mask of entries into the cargo translation table<td>example: <code>bitmask(PASS, MAIL, GOOD)</code>

<!-- properties common to all vehicle types but with different value ranges or meaning -->
<tr><td> sprite_id <td> SPRITE_ID_NEW_SHIP <td> define base set spriteID to replace or this constant
<tr><td> speed</td><td> 0 ... 127 km/h (speed units)</td><td></td></tr>
<tr><td> misc_flags <td> SHIP_FLAG_2CC <td> No other flags defined
<tr><td> refit_costs<td> <td> in 1/32 of the default refit cost base
<tr><td> callback_flags<td> CBF_XXX<td>XXX = [LOAD_AMOUNT | REFITTED_CAPACITY | CARGO_SUFFIX | COLOR_MAPPING | SOUND_EFFECT]

<!-- properties not present for all vehicle types -->
<tr><td> is_refittable <td> [0 | 1] <td>0=false, 1=true
<tr><td> cargo_capacity<td> (units of cargo)<td>
<tr><td> sound_effect<td> SOUND_XXX<td>XXX=[CARGO_SHIP|PASSENGER_SHIP] See available sound effects.
<tr><td> ocean_speed_fraction<td>0 ... 1<td> fraction of base speed on ocean tiles
<tr><td> canal_speed_fraction<td>0 ... 1<td> fraction of base speed on canal tiles
<tr><td> cargo_type<td> (cargo label)<td> use one from your cargo translation table

</table>
<h2><a name="property-planes">Planes</a></h2>
<table class="t">
<tr><th> property</th><th>value range</th><th>comment</th></tr>
<!-- properties common to all vehicle types -->
<tr><td> name</td><td>                         (string)</td><td>for example <code>string(STR_NAME_HEREFORD_TRAM)</code></td></tr>
<tr><td> climates_available</td><td>           BitMask(CLIMATE_XXX, CLIMATE_YYY, ...)</td><td>XXX = [TEMPERATE | ARCTIC | TROPIC | TOYLAND], alternatively CLIMATE_NONE or CLIMATE_ALL</td></tr>
<tr><td> model_life</td><td>                   0 ... 255 (years)</td><td></td></tr>
<tr><td> vehicle_life</td><td>                 0 ... 255 (years)</td><td></td></tr>
<tr><td> introduction_date</td><td>            date(yyyy,mm,dd)</td><td></td></tr>
<tr><td> reliability_decay</td><td>            0 ... 255</td><td>n/a</td></tr>
<tr><td> loading_speed <td>                    0 ... 255 (cargo units) <td> units loaded per tick
<tr><td> refittable_cargo_classes</td><td>     bit set of <a href="#property-cargos">cargo classes</a></td><td></td></tr>
<tr><td> non_refittable_cargo_classes</td><td> bit set of <a href="#property-cargos">cargo classes</a></td><td></td></tr>
<tr><td> retire_early<td> (years)<td>reliability of new vehicles starts to decrease <i>model life</i>-8-<i>retire_early</i> after vehicle introduction. Value of
<i>retire_early</i> may be negative.
<tr><td> cost_factor</td><td> 0 ... 255</td><td>purchase cost; mutliplicator to the base cost</td></tr>
<tr><td> running_cost_factor<td> 0 ... 255<td> multiplicator to the base running costs
<tr><td> refittable_cargo_types<td> bit mask of entries into the cargo translation table<td>example: <code>bitmask(PASS, MAIL, GOOD)</code>

<!-- properties common to all vehicle types but with different value ranges or meaning -->
<tr><td> sprite_id <td> SPRITE_ID_NEW_AIRCRAFT <td> define base set spriteID to replace or this constant
<tr><td> speed<td> 0 .. 4080 km/h (speed units)<td>
<tr><td> misc_flags<td> AIRCRAFT_FLAG_2CC<td>
<tr><td> refit_cost<td> <td> in 1/32 of default refit cost base
<tr><td> callback_flags<td> CBF_XXX<td>XXX = [LOAD_AMOUNT | REFITTED_CAPACITY | CARGO_SUFFIX | COLOR_MAPPING | SOUND_EFFECT]

<!-- properties not present for all vehicle types -->
<tr><td> is_helicopter<td> AIRCRAFT_TYPE_XXX<td>XXX=[NORMAL | HELICOPTER]
<tr><td> is_large<td> AIRCRAFT_TYPE_XXX<td>XXX=[SMALL | LARGE]
<tr><td> acceleration<td> <td>
<tr><td> passenger_capacity<td> (units of cargo)<td>
<tr><td> mail_capacity<td> (units of cargo)<td>
<tr><td> sound_effect<td> SOUND_XXX<td>XXX=[PROPELLER_1 | PROPELLER_2 | JET_1 | JET_2 | JET_3 | SUPERSONIC] see available sound effects
</table>
<h2><a name="property-stations">Stations</a></h2>
<h2><a name="property-canals">Canals</a></h2>
<h2><a name="property-bridges">Bridges</a></h2>
<h2><a name="property-houses">Houses</a></h2>
<h2><a name="property-industrytiles">Industry tiles</a></h2>
<h2><a name="property-industries">Industries</a></h2>
<h2><a name="property-cargos">Cargos</a></h2>
Available cargo classes are:
<table class="t">
<tr><th>name <th> type of cargo
<tr><td>CC_NONE <td> No cargo
<tr><td>CC_PASSENGERS<td> passengers, also tourists (ECS)
<tr><td>CC_MAIL<td> mail
<tr><td>CC_EXPRESS<td> express goods
<tr><td>CC_ARMOURED<td> valuables, diamonds, gold and alike
<tr><td>CC_BULK<td> coal, ore, grain,...
<tr><td>CC_PIECE_GOODS<td> containers, crates, livestock
<tr><td>CC_LIQUID<td> oil, milk, water, ...
<tr><td>CC_REFRIGERATED<td> food, milk, ...
<tr><td>CC_HAZARDOUS<td> chemicals? uranium, ...
<tr><td>CC_COVERED<td> grain, cement, fruit, ...
<tr><td>CC_OVERSIZED<td> ./.
<tr><td>CC_ALL_NORMAL<td> all except special classes like oversized and not yet defined ones
<tr><td>CC_ALL<td> all cargo classes
</table>
<h2><a name="property-airports">Airports</a></h2>
<h2><a name="property-railtypes">Railtypes</a></h2>
<table class="t">
<tr><th>property</th><th>value range</th><th>comment</th></tr>
<tr><td>label</td><td>                   4-byte string</td><td>names of default rail types: "RAIL", "ELRL", "MONO", "MLEV", "3RDR"</td></tr>
<tr><td>name</td><td>                    string</td><td></td></tr>
<tr><td>menu_text</td><td>               string</td><td></td></tr>
<tr><td>build_window_caption</td><td>    string</td><td></td></tr>
<tr><td>autoreplace_text</td><td>        string</td><td></td></tr>
<tr><td>new_engine_text</td><td>         string</td><td></td></tr>
<tr><td>compatible_railtype_list</td><td>list of railtype labels</td><td>e.g. ["RAIL", "ELRL", "MONO"]</td></tr>
<tr><td>powered_railtype_list</td><td>   list of railtype labels</td><td></td></tr>
<tr><td>railtype_flags</td><td>          RAILTYPE_FLAG_CATANERY | RAILTYPE_FLAG_NO_LEVEL_CROSSING (OpenTTD r20049)</td><td></td></tr>
<tr><td>curve_speed_multiplier</td><td>  0...65525</td><td>max curve speed is defined as multiple of the base curve speed (see below)</td></tr>
<tr><td>station graphics</td><td>        RAILTYPE_STATION_NORMAL, RAILTYPE_STATION_MONORAIL, RAILTYPE_STATION_MAGLEV</td><td></td></tr>
<tr><td>construction_cost</td><td>       0 ... 65525</td><td>per piece of track in GBP</td></tr>
<tr><td>speed_limit</td><td>             0 ... 65525 km/h (speed units)</td><td>A speed limit of 0 means unlimited speed</td></tr>
<tr><td>acceleration_model</td><td>      ACC_MODEL_RAIL, ACC_MODEL_MONORAIL, ACC_MODEL_MAGLEV</td><td>ACC_MODEL_RAIL and ACC_MODEL_MONORAIL behave the same currently</td></tr>
<tr><td>map_colour</td><td>              0 ... 255</td><td>entry in the colour palette</td></tr>
</table>

<!--
example table:
<table class="t">
<tr><th></th><th></th><th></th></tr>
<tr><td></td><td></td><td></td></tr>
</table>
-->
<p>
The base speeds relevant for the curve_speed_multiplier are:</p>
<table class="t">
<tr><th>curve length</th><th>base speed [km/h]</th></tr>
<tr><td>0 (90 degree turn)</td><td>30</td></tr>
<tr><td>1</td><td>44</td></tr>
<tr><td>2</td><td>55</td></tr>
<tr><td>3</td><td>66</td></tr>
<tr><td>4</td><td>75</td></tr>
<tr><td>5</td><td>84</td></tr>
<tr><td>6</td><td>91</td></tr>
<tr><td>7</td><td>98</td></tr>
<tr><td>8</td><td>103</td></tr>
<tr><td>9</td><td>108</td></tr>
<tr><td>10</td><td>111</td></tr>
<tr><td>11</td><td>114</td></tr>
<tr><td>12+</td><td>115</td></tr>
</table>

<p>Rail types define a number of fixed graphic blocks:</p>
<table class="t">
<tr><th>block name</th><th>number of sprites</th><th>meaning</th></tr>
<tr><td>GUI</td><td>         16</td><td>4 rail directions, autorail, depot, tunnel and convert rail sprites for rail menu</td></tr>
<tr><td>TRACKOVERLAY*</td><td>10</td><td>6 flat and 4 slope sprites. Track without landscape</td></tr>
<tr><td>UNDERLAY*</td><td>    16</td><td>6 flat and 4 slope, one crossing WITH track, 5 junction pieces without track. Tracks with foundations but without landscape</td></tr>
<tr><td>TUNNELS*</td><td>     4</td><td>4 track sprites, one for each tunnel entrance. Only track with foundations, no landscape</td></tr>
<tr><td>CATENERY_WIRE</td><td>28</td><td></td></tr>
<tr><td>CATENERY_PYLONS</td><td>8</td><td></td></tr>
<tr><td>BRIDGE_SURFACES</td><td>6</td><td></td></tr>
<tr><td>LEVEL_CROSSINGS*</td><td>10</td><td>For each direction: one track sprite and 4 sprites for road lights etc</td></tr>
<tr><td>DEPOTS*</td><td>6</td><td>2 sprites for each southish, 1 sprite for each nothish depot. Like original depots.</td></tr>
<tr><td>FENCES</td><td>8</td><td>x, y, vertical, horizontal, SW, SE, NE and NW slopes like original fences at sprite 1301</td></tr>
</table>

<p>The entries marked by * are required.</p>

<h2><a name="property-airporttiles">Airport tiles</a></h2>

<h2><a name="property-snowline">Snowline</a></h2>
The snowline is specified by a <code>snowline</code> statement. See the
example below:
<pre class="code">
snowline {
	day_of_year(2,  1):  2,
	day_of_year(11, 1):  4,
	177: 29,
	day_of_year(10, 1): 29,
	linear
}
</pre>
It starts with the <code>snowline</code> keyword, and contains a number of
<code>&lt;day-of-the-year&gt; : &lt;height&gt;</code>pairs. These define the
height of the snowline at that day in the year. The day of the year value is
actually an integer from 1 upto and including 365, so you may also define a
day as a number. Heights run from 2 (for snow everywhere) to 29, although 17
is already sufficient to remove all traces of snow from the game.
<p>For the days not listed, the program computes a height. It can do that in
two modes, namely in <code>equal</code> mode and in <code>linear</code> mode
(last line of text in the example). Default mode is <code>equal</code>.
In <code>equal</code> mode, the height of the snow is the same as the day before,
unless the day is listed in the <code>snowline</code> statement.
In <code>linear</code> mode, the height of the snowline gets linearly
interpolated between two heights specified in the statement.
In both cases, note that days `wrap around' at the end of the year, to get the
snow height of January 1st (if not listed in the statement), the last
specified height of the year is used in the calculation.


<h1><a name="vars">List of variables</a></h1>
<h2><a name="vars-global">General</a></h2>
<table class="t">
<tr><th>name <th>value range <th>comment
<tr><td>climate <td>CLIMATE_XXX with XXX = [TEMPERATE | ARCTIC | TROPIC | TOYLAND] <td>
<tr><td>ttdpatch_flags <td> <td>
<tr><td>trafic_side <td>DRIVE_ON_LEFT | DRIVE_ON_RIGHT <td>
<tr><td>ttdpatch_version <td> <td>
<tr><td>ttd_version <td> <td>
<tr><td>ttd_platform <td>PLATFORM_TTDPATCH | PLATFORM_OPENTTD <td>
<tr><td>openttd_version<td> <td>use version_openttd(MAJOR, MINOR, BUILD) to test and compare for a
    release version and version_openttd(MAJOR, MINOR, BUILD, REVISION) to test for a specific svn
    version of OpenTTD
<tr><td>date_loaded <td> <td>
<tr><td>year_loaded <td> <td>

</table>

<h2><a name="vars-trains">Trains</a></h2>
<table class="t">
<tr><th>name</th><th>value range</th><th>comment</th></tr>
<tr><td>position_in_consist <td>0 ... 255<td>
<tr><td>position_in_consist_from_end <td>0 ... 255 <td>
<tr><td>num_vehs_in_consist <td>0 ... 255 <td>
<tr><td>position_in_vehid_chain <td>0 ... 255 <td>
<tr><td>position_in_vehid_chain_from_end <td>0 ... 255 <td>
<tr><td>cargo_classes_in_consist <td>Bitmask of CC_XXX <td><a href="#property-cargos">cargo classes</a>
<tr><td>most_common_refit <td><a href="#property-cargos">cargo class</a><td>cargo class most often refit to
<tr><td>bitmask_consist_info <td>Bitmask 8 bit<td>OR of all bitmask_vehicle_info of all vehicles (engines, wagons) in the consist
<tr><td>company_num <td>0 ... 15<td>company number of the vehicle owner. TTDPatch only supports up to 8 companies
<tr><td>company_type <td>0 ... 3 <td>0: human; 1: AI; 2: human in AI company; 3: human company controlled by AI
<tr><td>company_color1 <td> <td>index into company colour
<tr><td>company_color2 <td> <td>index into company colour. It's the same as company_colour1, if no 2nd company colour is chosen.
<tr><td>curv_info_prev_cur <td> <td>
<tr><td>curv_info_cur_next <td> <td>
<tr><td>curv_info_prev_next <td> <td>
<tr><td>motion_counter <td> <td>
<tr><td>cargo_type_in_veh <td>entry in cargo translation table <td>
<tr><td>cargo_unit_weight <td>weight in 1/16t <td>
<tr><td>cargo_classes <td><a href="#property-cargos">cargo class</a><td>class of the currently transported cargo
<tr><td>vehicle_type_info <td> <td>
<tr><td>build_year <td>0 ... 5000000 <td>0-based year when the vehicle was built
<tr><td>vehicle_type_id <td> <td>
<tr><td>refit_cycle <td> <td>
<tr><td>vehicle_is_powered <td> [0 | 1]<td> vehicle provides power and is on the correct track type
<tr><td>vehicle_is_not_powered <td> [0 | 1]<td> vehicle is either on a wrong track type or it doesn't provide power at all
<tr><td>vehicle_is_potentially_powered <td> [0 | 1]<td> vehicle provides power, if it is on a suitable track type
<tr><td>vehicle_is_reversed <td> <td>
<tr><td>build_during_preview <td> <td>
<tr><td>current_railtype <td> 0 ... 15<td>The railtype where the vehicle is currently on. Either entry into current railtypes translation table (if defined), otherwise direct number. Available since OpenTTD r20164.
</table>
<h2><a name="vars-roadvehs">Road vehicles</a></h2>
<h2><a name="vars-ships">Ships</a></h2>
<h2><a name="vars-planes">Planes</a></h2>
<h2><a name="vars-stations">Stations</a></h2>
<h2><a name="vars-canals">Canals</a></h2>
<h2><a name="vars-bridges">Bridges</a></h2>
<h2><a name="vars-houses">Houses</a></h2>
<h2><a name="vars-industrytiles">Industry tiles</a></h2>
<h2><a name="vars-industries">Industries</a></h2>
<h2><a name="vars-cargos">Cargos</a></h2>
<h2><a name="vars-airports">Airports</a></h2>
<h2><a name="vars-railtypes">Railtypes</a></h2>
<table class="t">
<tr><th>name</th><th>value range</th><th>comment</th></tr>
<tr><td>terrain_type</td><td>         TILETYPE_NORMAL, TILETYPE_DESERT, TILETYPE_RAIN_FOREST, TILETYPE_SNOW</td><td></td></tr>
<tr><td>enhanced_tunnels</td><td>     0</td><td>should custom tunnel entrances be modified other values than 0 might be returned</td></tr>
<tr><td>level_crossing_status</td><td>LEVEL_CROSSING_CLOSED, LEVEL_CROSSING_OPEN</td><td></td></tr>
<tr><td>build_date <td>0 .. 5000000 <td>for depots only: build date of the depot in days since 0
</table>
<h2><a name="vars-airporttiles">Airport tiles</a></h2>

<h2><a name="default industries">Default industries</a></h2>
<ul>
<li>INDUSTRYTYPE_COAL_MINE</li>
<li>INDUSTRYTYPE_POWER_PLANT</li>
<li>INDUSTRYTYPE_SAWMILL</li>
<li>INDUSTRYTYPE_FOREST</li>
<li>INDUSTRYTYPE_OIL_REFINERY</li>
<li>INDUSTRYTYPE_OIL_RIG</li>
<li>INDUSTRYTYPE_TEMPERATE_FACTORY</li>
<li>INDUSTRYTYPE_TROPIC_FACTORY</li>
<li>INDUSTRYTYPE_PRINTING_WORKS</li>
<li>INDUSTRYTYPE_STEEL_MILL</li>
<li>INDUSTRYTYPE_TEMPERATE_ARCTIC_FARM</li>
<li>INDUSTRYTYPE_TROPIC_FARM</li>
<li>INDUSTRYTYPE_COPPER_ORE_MINE</li>
<li>INDUSTRYTYPE_OIL_WELLS</li>
<li>INDUSTRYTYPE_FOOD_PROCESSING_PLANT</li>
<li>INDUSTRYTYPE_PAPER_MILL</li>
<li>INDUSTRYTYPE_TEMPERATE_BANK</li>
<li>INDUSTRYTYPE_TROPIC_ARCTIC_BANK</li>
<li>INDUSTRYTYPE_GOLD_MINE</li>
<li>INDUSTRYTYPE_DIAMOND_MINE</li>
<li>INDUSTRYTYPE_IRON_ORE_MINE</li>
<li>INDUSTRYTYPE_FRUIT_PLANTATION</li>
<li>INDUSTRYTYPE_RUBBER_PLANTATION</li>
<li>INDUSTRYTYPE_WATER_WELL</li>
<li>INDUSTRYTYPE_WATER_TOWER</li>
<li>INDUSTRYTYPE_LUMBER_MILL</li>
<li>INDUSTRYTYPE_CANDYFLOSS_FOREST</li>
<li>INDUSTRYTYPE_SWEETS_FACTORY</li>
<li>INDUSTRYTYPE_BATTERY_FARM</li>
<li>INDUSTRYTYPE_COLA_WELLS</li>
<li>INDUSTRYTYPE_TOY_SHOP</li>
<li>INDUSTRYTYPE_TOY_FACTORY</li>
<li>INDUSTRYTYPE_PLASTIC_FOUNTAIN</li>
<li>INDUSTRYTYPE_FIZZY_DRINKS_FACTORY</li>
<li>INDUSTRYTYPE_BUBBLE_GENERATOR</li>
<li>INDUSTRYTYPE_TOFFE_QUARRY</li>
<li>INDUSTRYTYPE_SUGAR_MINE</li>
</ul><ul>
<li>INDUSTRYTYPE_UNKNOWN</li>
<li>INDUSTRYTYPE_TOWN</li>
</ul>
</body>
</html>
