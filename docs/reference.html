<html>
<head>
<title>NML documentation</title>
<style type="text/css">
pre {
	background: lightgrey;
}
</style>
</head>
<body>

<h1>Contents</h1>
<ul>
<li><a href="#preface">Preface</a></li>
<li><a href="#structure">Language structure</a></li>
<li><a href="#block-syntax">Block syntax</a></li>
<ul>
	<li><a href="#block-grf">GRF</a></li>
	<li><a href="#block-item">Item</a></li>
	<ul>
		<li><a href="#block-item-property">Property</a></li>
		<li><a href="#block-item-graphics">Graphics</a></li>
		<li><a href="#block-item-livery_override">Livery override</a></li>
	</ul>
	<li><a href="#block-spriteblock">Spriteblock</a></li>
	<ul>
		<li><a href="#block-spriteblock-spriteset">Spriteset</a></li>
		<li><a href="#block-spriteblock-spritegroup">Spritegroup</a></li>
	</ul>
	<li><a href="#block-switch">Switch</a></li>
	<li><a href="#block-template">Template</a></li>
	<li><a href="#block-cargotable">Cargotable</a></li>
	<li><a href="#block-if">If/else</a></li>
	<li><a href="#block-while">While</a></li>
	<li><a href="#block-error">Error</a></li>
	<li><a href="#block-deactivate">Deactivate</a></li>
	<li><a href="#block-replacement">Sprite replacement</a></li>
	<ul>
		<li><a href="#block-replacement-replace">Replace TTD sprites</a></li>
		<li><a href="#block-replacement-replacenew">Replace new sprites</a></li>
		<li><a href="#block-replacement-fontglpyh">Add font glpyhs</a></li>
	</ul>
	<li><a href="#block-town_names">Town names</a></li>
	<ul>
		<li><a href="#block-town_names-parts">Town names parts</a></li>
	</ul>
	<li><a href="#block-assignment">Parameter assignment</a></li>
</ul>
<li><a href="#units">Units</a></li>
<li><a href="#properties">List of properties</a></li>
<ul>
	<li><a href="#property-trains">Trains</a></li>
	<li><a href="#property-roadvehs">Road vehicles</a></li>
	<li><a href="#property-ships">Ships</a></li>
	<li><a href="#property-planes">Planes</a></li>
	<li><a href="#property-stations">Stations</a></li>
	<li><a href="#property-canals">Canals</a></li>
	<li><a href="#property-bridges">Bridges</a></li>
	<li><a href="#property-houses">Houses</a></li>
	<li><a href="#property-industrytiles">Industry tiles</a></li>
	<li><a href="#property-industries">Industries</a></li>
	<li><a href="#property-cargos">Cargos</a></li>
	<li><a href="#property-airports">Airports</a></li>
	<li><a href="#property-railtypes">Railtypes</a></li>
	<li><a href="#property-airporttiles">Airport tiles</a></li>
</ul>
<li><a href="#vars">List of variables</a></li>
<ul>
	<li><a href="#vars-trains">Trains</a></li>
	<li><a href="#vars-roadvehs">Road vehicles</a></li>
	<li><a href="#vars-ships">Ships</a></li>
	<li><a href="#vars-planes">Planes</a></li>
	<li><a href="#vars-stations">Stations</a></li>
	<li><a href="#vars-canals">Canals</a></li>
	<li><a href="#vars-bridges">Bridges</a></li>
	<li><a href="#vars-houses">Houses</a></li>
	<li><a href="#vars-industrytiles">Industry tiles</a></li>
	<li><a href="#vars-industries">Industries</a></li>
	<li><a href="#vars-cargos">Cargos</a></li>
	<li><a href="#vars-airports">Airports</a></li>
	<li><a href="#vars-railtypes">Railtypes</a></li>
	<li><a href="#vars-airporttiles">Airport tiles</a></li>
</ul>
</ul>

<h1><a name="preface">Preface</a></h1>
<p>NewGRF files are files containing sprites and pseudo-sprites that can be
used to describe extra vehicles, industries, cargoes etc. for use in OpenTTD
and TTDPatch. The most used tool to encode/decode GRF flies is
<a href="http://www.ttdpatch.net/grfcodec/">GRFCodec</a>
(<a href="http://www.openttd.org/download-grfcodec">nightly download</a>).
GRFCodec can read NFO files and convert them to GRF files
(<a href="http://www.ttdpatch.net/grfcodec/grf.html">GRF file format</a>).
NFO is a low-level language that is tied to the GRF spec. It uses hexadecimal
numbers by default in most places and doesn't have any textual identifiers.
While the language is very powerful, it's also hard to learn. NML was started
mainly to provide a higher level language so coding GRF files will become
accessable to more people.</p>

<h1><a name="structure">Language structure</a></h1>
<h2>Blocks</h2>
<p>NML files are mainly composed from blocks. A block starts with the type of
the block, optional arguments and then the contents enclosed by curly braces.
Nearly all NML files will start with a <a href="#block-grf">grf-block</a>. The
grf-block takes no parameters and is one of the simplest blocks there is.
Following is an example grf-block.
<pre>grf {
	grfid : "AB\02\03";
	name : string(STR_GRF_NAME);
	desc : string(STR_GRF_DESCRIPTION);
}</pre>
Let's look at this code line for line.
<pre>grf {</pre>
This block is a grf-block. A grf-block has no parameters. The '{' is the start
of the block content.
<pre>	grfid : "AB\02\03";</pre>
This line sets the grfid of the resulting grf. The value is the letters AB
followed by a byte with value 2 and then another one with value 3. The
semicolon marks the end of the statement.
<pre>	name : string(STR_GRF_NAME);</pre>
The name of the grf. In NML nearly all strings are put in
<a href="#language-files">language files</a>. The format of the language files
is described in another section. For now just assume a string with the name
<code>STR_GRF_NAME</code> exists. To reference a string from the language file
you use <code>string(&lt;stringname&gt;)</code> where <code>&lt;stringname&gt;</code>
should be replaced by the actual name of the string.
<pre>	desc : string(STR_GRF_DESCRIPTION);</pre>
This looks a lot like the previous line, only it sets the description instead
of the name.
<pre>}</pre>
This marks the end of the last-opened block, in this case the grf-block.</p>

<h2>Parameters</h2>
<p>Blocks are not the only item in NML files, you can also do parameter
assignments. Each NewGRF has 128 parameters available, NML reservers the top 64
parameters for internal use. If a user sets parameters for your grf, these are
the starting at parameter 0. Each parameter is available by using
<code>param[&lt;expression&gt;]</code>. You can set parameter number 4 to 3 by doing:
<pre>param[4] = 3;</pre>


<h1><a name="block-syntax">Block syntax</a></h1>
In the next sections you'll often see a word enclosed by the less-than and
greater-than symbols. These words should not be written literally, but instead
a references to another block/item you should use there. The following words
will be used:

<dl>
<dt>&lt;literal-string&gt;</dt>
<dd>A string enclosed by quotes, for example <code>"this is a literal string"</code></dd>

<dt>&lt;string&gt;</dt>
<dd>A string defined in the language file, for example <code>string(STR_GRF_NAME)</code></dd>

<dt>&lt;expression&gt;</dt>
<dd>An expression, this can computation or one of &lt;number&gt;, &lt;float&gt;,
&lt;parameter&gt;, &lt;variable&gt;, &lt;function-call&gt;</dd>

<dt>&lt;ID&gt;</dt>
<dd>The name of an item or block. IDs should start with a letter or underscore.
The rest of the ID may consist of letters, underscores or numbers.</dd>

</dl>
If something is enclosed by square brackes [] it's optional.


<h2><a name="block-grf">GRF</a></h2>
<pre>grf {
	grfid: &lt;literal-string&gt;;
	name: &lt;string&gt;;
	desc: &lt;string&gt;;
}</pre>
Example:
<pre>grf {
	grfid: "AB\03\02";
	name: string(STR_GRF_NAME);
	desc: string(STR_GRF_DESC);
}</pre>

<h2><a name="block-item">Item</a></h2>
<pre>item (&lt;expression&gt; [, &lt;ID&gt; [, &lt;expression&gt;]]) {
	(&lt;property-block&gt;|&lt;graphics-block&gt;|&lt;livery_override-block&gt;)+
}</pre>
The first argument is the feature of the item, the second (optional) argument
is the name and the third (optional) argument is the numerical id you want to
use for this item.
Example:
<pre>item (FEAT_ROADVEHS, hereford_tram) {
	property {
		name:               string(STR_NAME_HEREFORD_TRAM);
		climates_available: CLIMATE_BIT_ALL;
		introduction_date:  date(1940,1,1);
		speed:              60 km/h;
	}
}</pre>

<h3><a name="block-item-property">Property</a></h3>
<pre>property {
	(&lt;ID&gt;: (&lt;string&gt;|(&lt;expression&gt; [&lt;unit&gt;]));)+
}</pre>
This one looks a lot more complicated then it actually is. A property-block
contains one or more assignments. Each assignment starts with the name of the
property that is changed followed by a colon. After the colon follow the value
and you end the line with a semicolon. The type of the value depends on the
property, some properties require a string as value and some an expression.
For some properties you can optionally specify a unit that is used to convert
the value to the unit that is written to the output file. You can only use
a unit if the expression is constant. <a href="#units">List of valid units</a>

<h3><a name="block-item-graphics">Graphics</a></h3>
In general the layout for defining graphics is like
<pre>
spriteblock(FEATURE) {
	spriteset (SPRITESET_NAME, graphics_file) {
		[left_X, upper_Y, width, height, offset_X, offset_Y]
		...
	}
	spritegroup spritegroup_name {
		loading: spriteset_name
		loaded: spriteset_name
	}
}
</pre>
An example which defines two graphics for a train engine:
<pre>
spriteblock(FEAT_TRAINS) {
	spriteset(turbotrain_engine_set, "sprites/pcx/opengfx_trains_start.pcx") {
		[142,112,  8,22,   -3,-10]
		[158,112, 21,15,  -14, -7]
		[190,112, 31,12,  -16, -8]
		[238,112, 21,16,   -6, -7]
		[270,112,  8,24,   -3,-10]
		[286,112, 21,16,  -15, -6]
		[318,112, 32,12,  -16, -8]
		[366,112, 21,15,   -6, -7]
	}
	spritegroup turbotrain_engine_group {
		loading: turbotrain_engine_set;
		loaded: turbotrain_engine_set;
	}
}
spriteblock(FEAT_TRAINS) {
	spriteset(turbotrain_passenger_set, "sprites/pcx/opengfx_trains_start.pcx") {
		[142,139,  8,21,   -3,-10]
		[158,139, 20,15,  -13, -7]
		[190,139, 28,10,  -12, -6]
		[238,139, 20,16,   -6, -7]
		[270,139,  8,21,   -3,-10]
		[286,139, 20,15,  -15, -6]
		[318,139, 28,10,  -16, -6]
		[366,139, 20,16,   -6, -7]
	}
	spritegroup turbotrain_passenger_group {
		loading: turbotrain_passenger_set;
		loaded: turbotrain_passenger_set;
	}
}
</pre>
<h3><a name="block-item-livery_override">Livery override</a></h3>
A livery override block offers the possibility to change the look of an engine or wagon depending on wagons coupled to them, e.g. 
allowing a freight engine to be differently coloured than a passenger engine. The spritegroup needs to be defined before it can
be used in a livery override. A livery override block is always part of the engine definition and looks like
<pre>
livery_override (vehicleID) {
	spritegroup_name
}
</pre>
Concerning this example it is assumed that it is preceeded by the graphics definitions given as example in the <a href="#block-item-graphics">graphics definition</a>
and that a vehicleID "passenger_wagon" is defined. The engine will get different looks (spritegroup "turbotrain_passenger_group") in this example, if the passenger
wagon is attached. For all other wagons it will show sprites from "turbotrain_engine_group".
<pre>
// Turbotrain engine:
item(FEAT_TRAINS, turbotrain, 20) {
	property {
		sprite_id:                    SPRITE_ID_NEW_TRAIN;    // We have our own sprites
		misc_flags:                   TRAIN_FLAG_MU;          // We use special sprites for passenger wagons
	}
	graphics {
		turbotrain_engine_group;
	}
	livery_override(passenger_wagon) { 
		turbotrain_passenger_group;
	}
}
</pre>
<h2><a name="block-spriteblock">Spriteblock</a></h2>
<h3><a name="block-spriteblock-spriteset">Spriteset</a></h3>
<h3><a name="block-spriteblock-spritegroup">Spritegroup</a></h3>

<h2><a name="block-switch">Switch</a></h2>
<pre>switch (&lt;expression&gt;, (SELF|PARENT), &lt;ID&gt;, &lt;expression&gt;) {
	(&lt;range&gt;: &lt;return_value&gt;;)*
	&lt;return_value&gt;;
}</pre>
<p><code>&lt;range&gt;</code> can either number or two numbers seperated by
two dots.</p>
<p><code>&lt;return_value&gt;</code> can be either a literal <code>return</code>,
a literal <code>return</code> followed by an expression, an <code>ID</code> that
is the name of another switchblock or spriteblock or a string. If the
<code>return_value</code> is just a literal <code>return</code>, then the value
of the computation is returned. If it's a string or a <code>return</code>
followed by an expression then that value is returned. Otherwise it's the ID
of a spriteblock or switch and that block will be evaluated.

<h2><a name="block-template">Template</a></h2>

<h2><a name="block-cargotable">Cargotable</a></h2>
<pre>cargotable {
	ID [, ID]*
}</pre>
The cargotable is a list of 4-byte long IDs. For example:
<pre>cargotable {
	PASS, MAIL, GOOD, COAL
}</pre>

<h2><a name="block-if">If/else</a></h2>
<pre>
if (expression) { 
	block; 
} else { 
	block; 
}
</pre>
For example:
<pre>
if (param[1] == 1) { 
	param[2] = 3
} else {
	param[2] = 5
}
</pre>

<h2><a name="block-while">While</a></h2>

<h2><a name="block-error">Error</a></h2>

<h2><a name="block-deactivate">Deactivate</a></h2>

<h2><a name="block-replacement">Sprite replacement</a></h2>
<p>This section covers the three available methods to replace sprites.
Which one to use depends on the type of sprites you want to replace. The following
sections will outline the detailed functionality of these blocks and when to use them.</p>

<h3><a name="block-replacement-replace">Replace TTD sprites</a></h3>
<p>Using a <code>replace</code> block, it is possible to replace TTD's built-in sprites.
The syntax is as follows:</p>
<pre>replace(&lt;sprite-id&gt;, &lt;image-file&gt;) {
	&lt;real-sprites&gt;...
}</pre>
<p>The first parameter <code>&lt;sprite-id&gt;</code> should be a compile-time constant
that indicates the sprite number of the first sprite to replace. Sprite numbers are
equal to the sprite numbers in the base graphics file. The 
<a href="http://mz.openttdcoop.org/opengfx/authors/script.php?feature=spritesbyfile&amp;q=ogfx1_base">
OpenGFX author overview</a> can be used as a reference to look up these sprite numbers.
The second parameter <code>&lt;image-file&gt;</code> specifies the image file that contains
the new sprites. A series of real sprites has to be specified between the curly braces
(<code>{</code> and <code>}</code>). The first sprite in this list replaces sprite with id
<code>sprite-id</code>, the second replaces <code>sprite-id + 1</code> and so on.
Sprite templates can be used as well. For example:
<pre>
// Rail overlays for crossings
replace (1005, "src/gfx/rails_overlays.png") {
		[ 20,198, 40,21, -20,  5]
		[ 71,198, 40,21, -20,  5]
		[117,198, 40, 7, -20,  5]
		[165,198, 40, 7, -20, 21]
		[216,198, 12,19,  10,  5]
		[248,198, 12,19, -24, 11]
}
</pre></p>

<h3><a name="block-replacement-replacenew">Replace new sprites</a></h3>
<p>Over time, several features have been added to TTDPatch and OpenTTD that require new
sprites. As these sprites are not present in the original base graphics, they cannot
be replaced using a normal <code>replace</code> block. Instead, a <code>replacenew</code>
block has to be used. The semantics are like this:</p>
<pre>replacenew(&lt;type&gt;, &lt;image-file&gt;[, &lt;offset&gt;]) {
	&lt;real-sprites&gt;...
}</pre>
The <code>&lt;type&gt;</code> parameter indicates the type of sprites that will be replaced.
It should be an identifier from the first column of the following table.

<!-- This table could use some information regarding versioning, descriptions
 and references to which sprites are actually needed. However this is a lot
 of work (even TTDP wiki doesn't list all info) and this is not really a
 high priority job -->
<table>
	<tr><th>Type</th><th>Number of sprites</th></tr>
	<tr><td>PRE_SIGNAL</td><td>48</td></tr>
	<tr><td>PRE_SIGNAL_SEMAPHORE</td><td>112</td></tr>
	<tr><td>PRE_SIGNAL_SEMAPHORE_PBS</td><td>240</td></tr>
	<tr><td>CATERNARY</td><td>48</td></tr>
	<tr><td>FOUNDATIONS_SLOPES</td><td>74</td></tr>
	<tr><td>FOUNDATIONS_SLOPES_HALFTILES</td><td>90</td></tr>
	<tr><td>TTDP_GUI_25</td><td>73</td></tr>
	<tr><td>TTDP_GUI</td><td>93</td></tr>
	<tr><td>CANALS</td><td>65</td></tr>
	<tr><td>ONE_WAY_ROAD</td><td>6</td></tr>
	<tr><td>COLORMAP_2CC</td><td>256</td></tr>
	<tr><td>TRAMWAY</td><td>113</td></tr>
	<tr><td>SNOWY_TEMPERATE_TREES</td><td>133</td></tr>
	<tr><td>COAST_TILES</td><td>16</td></tr>
	<tr><td>COAST_TILES_BASEGFX</td><td>10</td></tr>
	<tr><td>COAST_TILES_DIAGONAL</td><td>18</td></tr>
	<tr><td>NEW_SIGNALS</td><td>any (a)</td></tr>
	<tr><td>SLOPED_RAILS</td><td>12</td></tr>
	<tr><td>AIRPORTS</td><td>15</td></tr>
	<tr><td>ROAD_STOPS</td><td>8</td></tr>
	<tr><td>AQUEDUCTS</td><td>8</td></tr>
	<tr><td>AUTORAIL</td><td>55</td></tr>
	<tr><td>FLAGS</td><td>36 (b)</td></tr>
	<tr><td>OTTD_GUI</td><td>154 (b)</td></tr>
</table>

<p>(a) Any number of sprites is allowed here, however both OpenTTD and
NML don't (yet) support the other features required to use these sprites.</p>

<p>(b) Any number of sprites can be specified up to the stated maximum.
Furthermore the <code>offset</code> variable can be used, see below for
more info.</p>

<p>The amount of sprites has to be equal to the number list has to be
equal to the number given in the table, except in the cases of (a) and (b).
Having less sprites results in an error. Having more sprites is allowed
to provide future compatibility, but a warning will be issued.</p>

<p>Parameter two <code>&lt;image-file&gt;</code> is a literal (quoted) string
that specifies the file where the sprites are located.</p>
<p>Parameter <code>&lt;offset&gt;</code> is optional and has a default value of 0.
Values greater than zero are only allowed in the case of the sprite types marked
with (b). Setting this value sets an offset into the block of sprites, so only a
subset of the sprites (starting at <code>offset</code>) will be replaced.</p>

<h3><a name="block-replacement-fontglpyh">Add font glpyhs</a></h3>
<p>A <code>font-glpyh</code> block makes it possible to provide sprites
for glyphs that don't have sprites in normal TTD. The syntax is as follows:</p>

<pre>font_glpyh (&lt;font-size&gt;, &lt;base-char&gt;, &lt;image-file&gt;) {
	&lt;real-sprites&gt;...
}</pre>

<p>The first parameter (<code>&lt;font-size&gt;</code>) should be an identifier
of the font size to use. Valid values are <code>SMALL</code>, <code>NORMAL</code>
and <code>LARGE</code>.</p>
<p>The second parameter (<code>&lt;base-char&gt;</code>) is the number
corresponding to the first character to provide a sprite for. Valid values are
all unicode code points in the Basic Multilingual Plane (0-0xFFFF)</p>
<p>Parameter three <code>&lt;image-file&gt;</code> is a literal (quoted) string
that specifies the file where the sprites are located.</p>
<p><code>&lt;real-sprites&gt;</code> should be a list of real sprites. The first
real sprite will be used for the character with code <code>base-char;</code>, the
second for <code>base-char + 1</code> and so on. These sprites should only use
color palette indices 0 (transparant), 1 (foreground) and 2 (shadow). If the
shadow color is used, sprite compression flag 'TILE' must NOT be set.</p>

<h2><a name="block-town_names">Town names</a></h2>
To define randomly generated town names, the <tt>town_names</tt> block should
be used. Such blocks can be used in two ways, as generator of (partial) town
names for another block, or as top-level town names block, the starting point of the
grf file. You must have at least one starting point, but you can have more
than one.
<p>The general syntax of a town names block is:
<pre>town_names[(&lt;name&gt;)] {
	[styles : &lt;string&gt;]
	&lt;part&gt; &lt;part&gt; ....
}</pre>
The optional <code>&lt;name&gt;</code> defines the name of the block. Such a
name is used to refer to this block from another town names block.
For top-level town names blocks, it is often left out. Note that in that case,
you must also leave out the parentheses.
<p>If specified, it can be either a number (from 0 up to 127), or an
identifier. Such a name is used to refer to this block from another town names
block. Note that if you leave out the name, you should also leave out the
parentheses.
<p>The optional <code>&lt;string&gt;</code> defines how the town names are
called in the menu. It may only be defined in a top-names block. To make the
name available in all languages, it is probably a good idea to at least define
a menu name if the generic language.

<h3><a name="block-town_names-parts">Town names parts</a></h3>
A <code>town_names</code> block has one or more <code>&lt;part&gt;</code>s.
Each part defines a piece of a town name. All pieces together form the name
generated by the block.
<p>An example of a part is
<pre>{
	text("name1", 1),
	text("name2", 2),
	town_names(othernames, 3)
}</pre>The simplest form is just a list of <code>text(...)</code>entries.
Each entry contains a possible value of piece, and a probability of picking
that name. The <code>town_names(&lt;name&gt;, &lt;probability&gt;)</code>calls
a previous <code>town_names</code> block (called 'othernames' in the example),
and returns the value generated there.
A part should have at least one and at most 255 entries.
<p>The numbers are the probabilities. In the example, the sum of all values is
6, which means that <code>name1</code> is picked with 1/6 chance,
<code>name2</code> has a 2/6 chance, and a name generated from the previous
<code>town_names</code> block has a 3/6 chance.


<h2><a name="block-assignment">Parameter assignment</a></h2>
<pre>param[&lt;expression&gt;] = &lt;expression&gt;;</pre>
Set a parameter to the given expression. Neither of the two expessions has to
be constant, the following is perfectly valid:
<pre>param[param[2] + 1] = param[3] * param[4];</pre>



<h1><a name="units">Units</a></h1>

<h1><a name="properties">List of properties</a></h1>
<h2><a name="property-trains">Trains</a></h2>
<h2><a name="property-roadvehs">Road vehicles</a></h2>
<table>
<tr><th> property</th><th>value range</th><th>comment</th></tr>
<tr><td> name</td><td>                      string(STR_NAME_HEREFORD_TRAM);
<tr><td> climates_available</td><td>           CLIMATE_BIT_XXX</td><td>XXX = [TEMPERATE | ARCTIC | TROPIC | TOYLAND]</td></tr>
<tr><td> model_life</td><td>                   0 ... 255 (years)</td><td></td></tr>
<tr><td> vehicle_life</td><td>                 0 ... 255 (years)</td><td></td></tr>
<tr><td> introduction_date</td><td>            date(yyyy,mm,dd)</td><td></td></tr> 
<tr><td> reliability_decay</td><td>            0 ... 255</td><td>n/a</td></tr>  
<tr><td> running_cost_base</td><td>            RUNNING_COST_XXX</td><td>XXX = [</td></tr> 
<tr><td> running_cost_factor</td><td>          0 ... 255</td><td>multiplicator to the base cost</td></tr> 
<tr><td> cost_factor</td><td>                  0 ... 255</td><td>mutliplicator to the base cost</td></tr> 
<tr><td> speed</td><td>                        0 ... 65000km/h (speed units)</td><td></td></tr> ;
<tr><td> power</td><td>                        0 ... 65000kN (power units)</td><td></td></tr> 
<tr><td> weight</td><td>                       0 ... 65000t (mass units)</td><td></td></tr> 
<tr><td> sprite_id</td><td>                    SPRITE_ID_NEW_ROADVEH</td><td>define base set spriteID to replace or this constant</td></tr> 
<tr><td> loading_speed</td><td>                0 ... 255 (1)</td><td>relative loading speed in artibrary units</td></tr> 
<tr><td> tractive_effort_coefficient</td><td>  0 ... 1</td><td></td></tr> 
<tr><td> air_drag_coefficient</td><td>         0 ... 1</td><td></td></tr> 
<tr><td> cargo_capacity</td><td>               0 ... 65000</td><td></td></tr> 
<tr><td> refittable_cargo_classes</td><td>     bit set of cargo classes</td><td></td></tr> 
<tr><td> non_refittable_cargo_classes</td><td> bit set of cargo classes</td><td></td></tr>
<tr><td> misc_flags</td><td>                   ROADVEH_FLAG_XXX</td><td>road vehicle flags</td></tr>
<tr><td> cargo_type</td><td>                   default cargo as cargo label</td><td></td></tr> 

</table>
<h2><a name="property-ships">Ships</a></h2>
<h2><a name="property-planes">Planes</a></h2>
<h2><a name="property-stations">Stations</a></h2>
<h2><a name="property-canals">Canals</a></h2>
<h2><a name="property-bridges">Bridges</a></h2>
<h2><a name="property-houses">Houses</a></h2>
<h2><a name="property-industrytiles">Industry tiles</a></h2>
<h2><a name="property-industries">Industries</a></h2>
<h2><a name="property-cargos">Cargos</a></h2>
<h2><a name="property-airports">Airports</a></h2>
<h2><a name="property-railtypes">Railtypes</a></h2>
<h2><a name="property-airporttiles">Airport tiles</a></h2>

<h1><a name="vars">List of variables</a></h1>
<h2><a name="vars-trains">Trains</a></h2>
<h2><a name="vars-roadvehs">Road vehicles</a></h2>
<h2><a name="vars-ships">Ships</a></h2>
<h2><a name="vars-planes">Planes</a></h2>
<h2><a name="vars-stations">Stations</a></h2>
<h2><a name="vars-canals">Canals</a></h2>
<h2><a name="vars-bridges">Bridges</a></h2>
<h2><a name="vars-houses">Houses</a></h2>
<h2><a name="vars-industrytiles">Industry tiles</a></h2>
<h2><a name="vars-industries">Industries</a></h2>
<h2><a name="vars-cargos">Cargos</a></h2>
<h2><a name="vars-airports">Airports</a></h2>
<h2><a name="vars-railtypes">Railtypes</a></h2>
<h2><a name="vars-airporttiles">Airport tiles</a></h2>

</body>
</html>
